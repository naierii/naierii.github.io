{"version":3,"file":"static/js/369.0b688528.chunk.js","mappings":"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","sources":["components/three/CustomiserMesh/CustomiserMesh.tsx","components/three/Model/Model.tsx","components/three/DecalGraphic/DecalGraphic.tsx","components/three/DecalText/DecalText.tsx","components/three/ModelDecals/ModelDecals.tsx","components/three/ModelMerge/ModelMerge.tsx","components/three/Scene/Scene.tsx"],"sourcesContent":["import { findNavItem } from '@lib/object';\r\nimport { MaterialTextureMapModel } from '@models';\r\nimport { useTexture } from '@react-three/drei';\r\nimport { TextCustomiser, useCustomiserStore } from '@store/customiser';\r\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react';\r\nimport {\r\n  Box3,\r\n  DoubleSide,\r\n  Mesh,\r\n  MeshStandardMaterial,\r\n  RepeatWrapping,\r\n  Texture,\r\n  Vector3,\r\n} from 'three';\r\nexport interface ClonedTextureMeshProps {\r\n  node: Mesh;\r\n  texture: MaterialTextureMapModel;\r\n  tasselsTexture: MaterialTextureMapModel;\r\n  tassels: boolean;\r\n  hex: string;\r\n}\r\n\r\nconst ClonedTextureMesh = ({\r\n  node,\r\n  texture,\r\n  tasselsTexture,\r\n  tassels,\r\n  hex,\r\n}: ClonedTextureMeshProps) => {\r\n  const [textures, setTextures] = useState<MaterialTextureMapModel>();\r\n  const materialRef = useRef<MeshStandardMaterial>(null);\r\n  const meshRef = useRef<Mesh>(null);\r\n\r\n  const [isPointerDown, setIsPointerDown] = useState(false);\r\n  const [isPointerMoved, setIsPointerMoved] = useState(false);\r\n\r\n  const clonedTextures = useMemo(\r\n    () => Object.fromEntries(Object.entries(texture).map(([k, v]) => [k, v.clone()])),\r\n    [texture],\r\n  );\r\n\r\n  const {\r\n    customProduct,\r\n    setSelectedNav,\r\n    selectedNav,\r\n    savedParts,\r\n    navTabs,\r\n    texts,\r\n    flags,\r\n    graphics,\r\n    updateText,\r\n    updateIsMinimizedCustomiserNav,\r\n  } = useCustomiserStore();\r\n\r\n  const editText = useMemo(() => texts.find((t) => t.edit), [texts]);\r\n  const editFlag = useMemo(() => flags.find((t) => t.edit), [flags]);\r\n  const editGraphic = useMemo(() => graphics.find((t) => t.edit), [graphics]);\r\n\r\n  const part = useMemo(\r\n    () =>\r\n      customProduct?.attributes?.parts?.find((p) =>\r\n        p?.modelParts?.data.find(\r\n          (mp) =>\r\n            mp.attributes?.nodeId === node.userData.name || mp.attributes?.nodeId === node.name,\r\n        ),\r\n      ),\r\n    [customProduct, node],\r\n  );\r\n\r\n  const hexUse = part?.name === 'Crystals' ? hex : undefined;\r\n\r\n  const navItem = useMemo(() => {\r\n    if (!part?.id) return;\r\n\r\n    return findNavItem({\r\n      navTabs,\r\n      value: part.id,\r\n      key: 'id',\r\n    });\r\n  }, [part, navTabs]);\r\n\r\n  const navItemText = useMemo(() => {\r\n    if (!part?.id) return;\r\n\r\n    return findNavItem({\r\n      navTabs,\r\n      value: 'names',\r\n      key: 'type',\r\n    });\r\n  }, [navTabs]);\r\n\r\n  useEffect(() => {\r\n    if (clonedTextures && meshRef.current) {\r\n      let updatedTextures: MaterialTextureMapModel = {};\r\n      for (const [key, clone] of Object.entries(clonedTextures)) {\r\n        clone.wrapS = clone.wrapT = RepeatWrapping;\r\n        const boundingBox = new Box3().setFromObject(meshRef.current);\r\n        const boxSize = new Vector3();\r\n        const dimensions = boundingBox.getSize(boxSize);\r\n        const area = dimensions.x * dimensions.y;\r\n        clone.repeat.set(0.0005 * area, 0.0005 * area);\r\n        updatedTextures = { ...updatedTextures, [key]: clone };\r\n      }\r\n\r\n      setTextures(updatedTextures);\r\n    }\r\n  }, [clonedTextures]);\r\n\r\n  if (materialRef.current) {\r\n    materialRef.current.needsUpdate = true;\r\n  }\r\n\r\n  return (\r\n    <>\r\n      <mesh\r\n        name={node.name}\r\n        geometry={node.geometry}\r\n        ref={meshRef}\r\n        userData={{\r\n          name: node.userData.name,\r\n        }}\r\n        onPointerDown={(e) => {\r\n          setIsPointerDown(true);\r\n        }}\r\n        onPointerUp={() => {\r\n          setIsPointerMoved(false);\r\n          setIsPointerDown(false);\r\n        }}\r\n        onPointerMove={(e) => {\r\n          if (isPointerDown) {\r\n            setIsPointerMoved(true);\r\n          }\r\n        }}\r\n        onClick={(e) => {\r\n          setIsPointerDown(false);\r\n          setIsPointerMoved(false);\r\n\r\n          if (isPointerMoved) {\r\n            return;\r\n          }\r\n\r\n          if (editText?.key || editFlag?.key || editGraphic?.key) {\r\n            return;\r\n          }\r\n\r\n          const intersectedText = e.intersections.find(\r\n            (intersection) => intersection.object.userData.text,\r\n          )?.object.userData.text as TextCustomiser | undefined;\r\n\r\n          /**\r\n           * If text is clicked, go to NavItem to text\r\n           */\r\n          if (\r\n            navItemText &&\r\n            navItemText.index !== undefined &&\r\n            intersectedText &&\r\n            intersectedText.key\r\n          ) {\r\n            updateIsMinimizedCustomiserNav(false);\r\n            setSelectedNav(navItemText.index);\r\n            updateText(intersectedText.key, { edit: true });\r\n\r\n            return;\r\n          }\r\n\r\n          /**\r\n           * If mesh part is clicked, go to NavItem of part\r\n           */\r\n          if (\r\n            navItem &&\r\n            navItem.index !== undefined &&\r\n            e.intersections[0].object.name === node.name\r\n          ) {\r\n            e.stopPropagation();\r\n\r\n            updateIsMinimizedCustomiserNav(false);\r\n            setSelectedNav(navItem.index);\r\n          }\r\n        }}\r\n      >\r\n        {tassels ? (\r\n          <meshStandardMaterial\r\n            ref={materialRef}\r\n            {...tasselsTexture}\r\n            transparent\r\n            bumpScale={0.15}\r\n            // color={'hex'}\r\n            side={DoubleSide}\r\n            metalness={-0.5}\r\n          />\r\n        ) : (\r\n          <meshStandardMaterial\r\n            side={DoubleSide}\r\n            {...textures}\r\n            displacementScale={textures?.displacementMap ? -0.001 : undefined}\r\n            ref={materialRef}\r\n            color={hexUse}\r\n          />\r\n        )}\r\n      </mesh>\r\n    </>\r\n  );\r\n};\r\nexport interface CustomiserMeshProps {\r\n  node: Mesh;\r\n  nodeId: string;\r\n}\r\n\r\nconst CustomiserMesh = ({ node, nodeId }: CustomiserMeshProps) => {\r\n  const texture = useCustomiserStore(useCallback((state) => state.texture(nodeId), [nodeId]));\r\n  const optional = useCustomiserStore(useCallback((state) => state.optional(nodeId), [nodeId]));\r\n  // const tassels = useCustomiserStore(useCallback((state) => state.tassels(nodeId), [nodeId]));\r\n  const tassels = !!nodeId.includes('default');\r\n\r\n  const materialTexture = useTexture({ ...texture.materials });\r\n  const tasselsTexture = useTexture(\r\n    {\r\n      alphaMap:\r\n        'https://boxxer-api-dev.nyc3.cdn.digitaloceanspaces.com/tassels/tassels-opacity.jpg',\r\n      bumpMap: 'https://boxxer-api-dev.nyc3.cdn.digitaloceanspaces.com/tassels/tassels-bump.jpg',\r\n      map: texture.materials.map,\r\n    },\r\n    (textures) => {\r\n      const [bumpMap, alphaMap, map] = textures as Texture[];\r\n      alphaMap.wrapS = alphaMap.wrapT = RepeatWrapping;\r\n      alphaMap.flipY = false;\r\n      alphaMap.repeat.set(1.5, 1);\r\n      alphaMap.needsUpdate = true;\r\n      bumpMap.wrapS = bumpMap.wrapT = RepeatWrapping;\r\n      bumpMap.flipY = false;\r\n      bumpMap.repeat.set(1.5, 1);\r\n      bumpMap.needsUpdate = true;\r\n      map.wrapS = bumpMap.wrapT = RepeatWrapping;\r\n      map.flipY = false;\r\n      map.repeat.set(1.5, 1);\r\n      map.needsUpdate = true;\r\n    },\r\n  );\r\n\r\n  if (optional) {\r\n    return null;\r\n  }\r\n\r\n  return (\r\n    <ClonedTextureMesh\r\n      node={node}\r\n      texture={materialTexture}\r\n      tasselsTexture={tasselsTexture}\r\n      tassels={tassels}\r\n      hex={texture.hex}\r\n    />\r\n  );\r\n};\r\n\r\nexport default CustomiserMesh;\r\n","import { Maybe, ModelFragment } from '@graphql/generated/graphql';\r\nimport { useGLTF } from '@react-three/drei';\r\nimport { Fragment, useEffect } from 'react';\r\nimport { Material, Mesh } from 'three';\r\nimport { GLTF } from 'three-stdlib';\r\nimport CustomiserMesh from '../CustomiserMesh';\r\nimport { ModelMergeNodes } from '../ModelMerge/ModelMerge';\r\nexport interface CustomiserModelProps {\r\n  model?: Maybe<ModelFragment>;\r\n  addNodes: (newNodes: ModelMergeNodes, remove?: boolean) => void;\r\n}\r\n\r\n// const parts = [\r\n//   {\r\n//     id: 1,\r\n//     attributes: {\r\n//       nodeId: 'LeePerrySmith',\r\n//     },\r\n//   },\r\n// ];\r\n\r\ntype GLTFResult = GLTF & {\r\n  nodes: { [name: string]: Mesh };\r\n  materials: { [name: string]: Material };\r\n};\r\n\r\nconst Model = ({ model, addNodes }: CustomiserModelProps) => {\r\n  const { nodes } = useGLTF(\r\n    model?.attributes?.model?.data?.attributes?.url as string,\r\n  ) as unknown as GLTFResult;\r\n\r\n  useEffect(() => {\r\n    delete nodes['Scene'];\r\n    addNodes(nodes);\r\n\r\n    return () => {\r\n      addNodes(nodes, true);\r\n    };\r\n  }, [nodes]);\r\n\r\n  return (\r\n    <>\r\n      {model?.attributes?.parts?.data.map((part) => {\r\n        return (\r\n          <Fragment key={part.id}>\r\n            {part?.attributes?.nodeId && (\r\n              <CustomiserMesh\r\n                key={part.attributes.nodeId}\r\n                node={nodes[part.attributes.nodeId]}\r\n                nodeId={part.attributes.nodeId}\r\n              />\r\n            )}\r\n          </Fragment>\r\n        );\r\n      })}\r\n    </>\r\n  );\r\n};\r\n\r\nexport default Model;\r\n","import { Decal, useTexture } from '@react-three/drei';\r\nimport { EulerArray, FlagCustomiser, GraphicCustomiser, Vector3Array } from '@store/customiser';\r\nimport { log } from 'console';\r\nimport { useMemo } from 'react';\r\nimport { Euler, EulerOrder, MathUtils, Vector3 } from 'three';\r\nexport interface DecalGraphicProps {\r\n  flag?: FlagCustomiser;\r\n  graphic?: GraphicCustomiser;\r\n  position: Vector3Array;\r\n  orientation: EulerArray;\r\n  scale?: number;\r\n}\r\n\r\nconst DecalGraphic = ({ flag, graphic, position, orientation, scale = 1 }: DecalGraphicProps) => {\r\n  const texture = flag?.flag?.attributes?.image.data?.attributes?.url\r\n    ? [flag.flag.attributes.image.data.attributes.url]\r\n    : graphic?.graphic?.attributes?.image?.data?.attributes?.url\r\n    ? [graphic.graphic.attributes.image.data.attributes.url]\r\n    : [];\r\n\r\n  const isVisibleItem = (flag || graphic)?.isVisible;\r\n  const isVisible = typeof isVisibleItem === 'undefined' ? true : isVisibleItem;\r\n\r\n  const [image] = useTexture(texture);\r\n\r\n  const ratio = useMemo(() => {\r\n    const width = image.source.data.width ?? 1;\r\n    const height = image.source.data.height ?? 1;\r\n    return width / height;\r\n  }, [image]);\r\n\r\n  const rotationModifier = useMemo(() => {\r\n    const orientationCopy = new Euler().fromArray(\r\n      orientation as [number, number, number, (EulerOrder | undefined)?, ...any[]],\r\n    );\r\n    const currentAngle = MathUtils.radToDeg(orientationCopy.z);\r\n    const decalRotation = flag?.decalRotation || graphic?.decalRotation;\r\n    const newAngle = currentAngle + (decalRotation ?? 0);\r\n    orientationCopy.z = MathUtils.degToRad(newAngle);\r\n    return orientationCopy;\r\n  }, [flag?.decalRotation, graphic?.decalRotation, orientation]);\r\n\r\n  const scaleModifier = useMemo(() => {\r\n    return new Vector3(1 * ratio * scale, 1 * scale, 4);\r\n  }, [scale]);\r\n\r\n  if (!image) {\r\n    return null;\r\n  }\r\n\r\n  return (\r\n    <Decal position={position} rotation={rotationModifier} scale={scaleModifier}>\r\n      <meshPhongMaterial\r\n        map={image}\r\n        transparent\r\n        depthTest\r\n        depthWrite={false}\r\n        polygonOffset\r\n        polygonOffsetFactor={-20}\r\n        needsUpdate\r\n        opacity={isVisible ? 1 : 0}\r\n      />\r\n    </Decal>\r\n  );\r\n};\r\n\r\nexport default DecalGraphic;\r\n","import { Decal } from '@react-three/drei';\r\nimport { EulerArray, TextCustomiser, Vector3Array } from '@store/customiser';\r\nimport { useEffect, useMemo, useRef, useState } from 'react';\r\nimport {\r\n  Euler,\r\n  EulerOrder,\r\n  MathUtils,\r\n  MeshStandardMaterial,\r\n  Texture,\r\n  Vector2,\r\n  Vector3,\r\n} from 'three';\r\n\r\nexport interface DecalTextProps {\r\n  text?: TextCustomiser;\r\n  position: Vector3Array;\r\n  orientation: EulerArray;\r\n  scale?: number;\r\n}\r\n\r\nconst DecalText = ({ text = {}, position, orientation, scale = 1 }: DecalTextProps) => {\r\n  const rotationModifier = useMemo(() => {\r\n    const orientationCopy = new Euler().fromArray(\r\n      orientation as [number, number, number, (EulerOrder | undefined)?, ...any[]],\r\n    );\r\n    const currentAngle = MathUtils.radToDeg(orientationCopy.z);\r\n    const newAngle = currentAngle + (text?.decalRotation ?? 0);\r\n    orientationCopy.z = MathUtils.degToRad(newAngle);\r\n    return orientationCopy;\r\n  }, [text?.decalRotation, orientation]);\r\n\r\n  const texture =\r\n    text?.material?.attributes?.images?.length &&\r\n    text.material.attributes.images[0]?.image.data?.attributes?.url\r\n      ? [text.material.attributes.images[0].image.data.attributes.url]\r\n      : [];\r\n\r\n  // const isShiny = shouldNormalMap ? false : true;\r\n\r\n  const isLuxury: boolean = text.selectedName?.id === '2' ? true : false;\r\n  const hasPuff: boolean = text.puffPrice ? true : false;\r\n  const hasCrystals: boolean = text.crystalPrice ? true : false;\r\n\r\n  const shouldNormalMap =\r\n    hasCrystals ||\r\n    (text.normalMap instanceof Texture && text.selectedName?.attributes?.name === 'Luxury');\r\n  const normalMap = shouldNormalMap ? text.normalMap : null;\r\n  console.log('shouldNormalMap', shouldNormalMap);\r\n\r\n  const textIsVisible = typeof text.isVisible === 'undefined' ? true : text.isVisible;\r\n\r\n  let normalScale = 1;\r\n  if (hasCrystals) {\r\n    normalScale = 4;\r\n  } else if (isLuxury && !hasPuff) {\r\n    normalScale = 0.5;\r\n  } else if (isLuxury && hasPuff) {\r\n    normalScale = 3;\r\n  }\r\n\r\n  const scaleModifier = useMemo(() => {\r\n    return new Vector3(3.2 * scale, 0.4 * scale, 4);\r\n  }, [scale]);\r\n\r\n  const matRef = useRef<MeshStandardMaterial>(null);\r\n\r\n  const [refreshCount, setRefreshCount] = useState(0);\r\n\r\n  useEffect(() => {\r\n    if (text.preview && matRef.current && text.preview instanceof Texture) {\r\n      text.preview.needsUpdate = true;\r\n      matRef.current.needsUpdate = true;\r\n    }\r\n  }, [text.preview]);\r\n\r\n  useEffect(() => {\r\n    setRefreshCount((cur) => cur + 1);\r\n  }, [text.normalMap, text.puffPrice, text.crystalPrice, text.selectedName?.id]);\r\n\r\n  return (\r\n    <Decal key={refreshCount} position={position} rotation={rotationModifier} scale={scaleModifier}>\r\n      <meshStandardMaterial\r\n        ref={matRef}\r\n        transparent\r\n        roughness={isLuxury && !hasCrystals ? 1 : 0}\r\n        depthTest\r\n        depthWrite={false}\r\n        map={text.preview instanceof Texture ? text.preview : null}\r\n        normalMap={normalMap}\r\n        normalScale={new Vector2(normalScale, normalScale)}\r\n        opacity={textIsVisible ? 1 : 0}\r\n      ></meshStandardMaterial>\r\n    </Decal>\r\n  );\r\n};\r\n\r\nexport default DecalText;\r\n","import { useCustomiserStore } from '@store/customiser';\r\nimport { BufferGeometry } from 'three';\r\nimport DecalGraphic from '../DecalGraphic';\r\nimport DecalText from '../DecalText';\r\n\r\nexport interface ModelDecalsProps {\r\n  geom: BufferGeometry;\r\n}\r\n\r\nconst ModelDecals = ({ geom }: ModelDecalsProps) => {\r\n  const flags = useCustomiserStore((state) => state.flags);\r\n  const texts = useCustomiserStore((state) => state.texts);\r\n  const graphics = useCustomiserStore((state) => state.graphics);\r\n  return (\r\n    <mesh geometry={geom} renderOrder={1}>\r\n      <meshStandardMaterial transparent colorWrite={false} />\r\n      {flags.map((flag) => {\r\n        if (flag.decalPosition && flag.decalOrientation)\r\n          return (\r\n            <DecalGraphic\r\n              key={flag.key}\r\n              flag={flag}\r\n              position={flag.decalPosition}\r\n              orientation={flag.decalOrientation}\r\n              scale={flag.decalScale}\r\n            />\r\n          );\r\n      })}\r\n      {graphics.map((graphic) => {\r\n        if (graphic.decalPosition && graphic.decalOrientation)\r\n          return (\r\n            <DecalGraphic\r\n              key={graphic.key}\r\n              graphic={graphic}\r\n              position={graphic.decalPosition}\r\n              orientation={graphic.decalOrientation}\r\n              scale={graphic.decalScale}\r\n            />\r\n          );\r\n      })}\r\n      {texts.map((text) => {\r\n        if (text.decalPosition && text.decalOrientation)\r\n          return (\r\n            <DecalText\r\n              key={text.key}\r\n              text={text}\r\n              position={text.decalPosition}\r\n              orientation={text.decalOrientation}\r\n              scale={text.decalScale}\r\n            />\r\n          );\r\n      })}\r\n    </mesh>\r\n  );\r\n};\r\n\r\nexport default ModelDecals;\r\n","import { useCustomiserStore } from '@store/customiser';\r\nimport { ReactElement, useMemo, useState } from 'react';\r\nimport { BufferGeometry, Material, Mesh } from 'three';\r\nimport * as BufferGeometryUtils from 'three/examples/jsm/utils/BufferGeometryUtils';\r\n\r\nexport type ModelMergeNodes = {\r\n  [name: string]: Mesh<BufferGeometry, Material | Material[]>;\r\n};\r\n\r\nexport interface ModelMergeProps {\r\n  children(addNodes: {\r\n    addNodes: (newNodes: ModelMergeNodes, remove?: boolean) => void;\r\n    geom: BufferGeometry | null;\r\n  }): ReactElement;\r\n}\r\n\r\nconst ModelMerge = ({ children }: ModelMergeProps) => {\r\n  const [nodes, setNodes] = useState<ModelMergeNodes>();\r\n  const { customProduct } = useCustomiserStore();\r\n\r\n  const geom = useMemo(() => {\r\n    const geometries = [];\r\n    if (nodes) {\r\n      for (const [nodeId, node] of Object.entries(nodes)) {\r\n        const optionalPart = (customProduct?.attributes?.parts ?? [])\r\n          .filter((p) => p?.optional)\r\n          .map((p) => p?.modelParts?.data)\r\n          .flat()\r\n          .find((p) => p?.attributes?.nodeId === nodeId);\r\n\r\n        if (node.isMesh && !optionalPart) {\r\n          geometries.push(node.geometry.clone());\r\n        }\r\n      }\r\n    }\r\n\r\n    return geometries.length ? BufferGeometryUtils.mergeBufferGeometries(geometries) : null;\r\n  }, [nodes]);\r\n\r\n  function addNodes(newNodes: ModelMergeNodes, remove?: boolean) {\r\n    if (remove) {\r\n      const cleanNodes = { ...nodes };\r\n      for (const k in newNodes) {\r\n        delete cleanNodes[k];\r\n      }\r\n      setNodes({ ...cleanNodes });\r\n    } else {\r\n      setNodes((prev) => ({ ...prev, ...newNodes }));\r\n    }\r\n  }\r\n\r\n  return children({\r\n    addNodes,\r\n    geom,\r\n  });\r\n};\r\n\r\nexport default ModelMerge;\r\n","import { EventHandlers } from '@react-three/fiber/dist/declarations/src/core/events';\r\nimport { CustomiserState, useCustomiserStore } from '@store/customiser';\r\nimport { useDesignStore } from '@store/design';\r\nimport { forwardRef, useEffect } from 'react';\r\nimport { Group, MathUtils } from 'three';\r\nimport Model from '../Model';\r\nimport ModelDecals from '../ModelDecals';\r\nimport ModelMerge from '../ModelMerge';\r\n\r\nconst models = (state: CustomiserState) => state.selectedModels;\r\n\r\nexport interface SceneProps {\r\n  onPointerDown?: EventHandlers['onPointerDown'];\r\n  onPointerUp?: EventHandlers['onPointerUp'];\r\n  onPointerMove?: EventHandlers['onPointerMove'];\r\n  onClick?: EventHandlers['onClick'];\r\n}\r\n\r\nconst Scene = forwardRef<Group, SceneProps>(\r\n  ({ onPointerDown, onPointerUp, onPointerMove, onClick }: SceneProps, groupRef) => {\r\n    const selectedModels = useCustomiserStore(models);\r\n    const { remountTrigger } = useCustomiserStore();\r\n    const modelRotation = useDesignStore((state) => state.modelRotation);\r\n    const addingToCart = useDesignStore((state) => state.addingToCart);\r\n\r\n    useEffect(() => {\r\n      if (addingToCart && typeof groupRef !== 'function' && groupRef?.current) {\r\n        groupRef.current.rotateY(MathUtils.degToRad(modelRotation));\r\n      }\r\n    }, [addingToCart, modelRotation]);\r\n\r\n    return (\r\n      <group\r\n        name='meshGroup'\r\n        ref={groupRef}\r\n        onPointerDown={onPointerDown}\r\n        onPointerUp={onPointerUp}\r\n        onPointerMove={onPointerMove}\r\n        onClick={onClick}\r\n        dispose={null}\r\n      >\r\n        <ModelMerge key={remountTrigger}>\r\n          {({ addNodes, geom }) => (\r\n            <>\r\n              {selectedModels.map((m) => (\r\n                <Model key={m.model?.id} model={m.model} addNodes={addNodes} />\r\n              ))}\r\n              {geom && <ModelDecals geom={geom} />}\r\n            </>\r\n          )}\r\n        </ModelMerge>\r\n      </group>\r\n    );\r\n  },\r\n);\r\nScene.displayName = 'Scene';\r\n\r\nexport default Scene;\r\n"],"names":["ClonedTextureMesh","_ref","node","texture","tasselsTexture","tassels","hex","textures","setTextures","useState","materialRef","useRef","meshRef","isPointerDown","setIsPointerDown","isPointerMoved","setIsPointerMoved","clonedTextures","useMemo","Object","fromEntries","entries","map","_ref2","k","v","clone","customProduct","setSelectedNav","selectedNav","savedParts","navTabs","texts","flags","graphics","updateText","updateIsMinimizedCustomiserNav","useCustomiserStore","editText","find","t","edit","editFlag","editGraphic","part","_customProduct$attrib","_customProduct$attrib2","attributes","parts","p","_p$modelParts","modelParts","data","mp","_mp$attributes","_mp$attributes2","nodeId","userData","name","hexUse","undefined","navItem","id","findNavItem","value","key","navItemText","useEffect","current","updatedTextures","wrapS","wrapT","RepeatWrapping","boundingBox","Box3","setFromObject","boxSize","Vector3","dimensions","getSize","area","x","y","repeat","set","needsUpdate","_jsx","_Fragment","children","geometry","ref","onPointerDown","e","onPointerUp","onPointerMove","onClick","_e$intersections$find","intersectedText","intersections","intersection","object","text","index","stopPropagation","transparent","bumpScale","side","DoubleSide","metalness","displacementScale","displacementMap","color","_ref3","useCallback","state","optional","includes","materialTexture","useTexture","materials","alphaMap","bumpMap","flipY","_model$attributes","_model$attributes$mod","_model$attributes$mod2","_model$attributes$mod3","_model$attributes2","_model$attributes2$pa","model","addNodes","nodes","useGLTF","url","_part$attributes","Fragment","CustomiserMesh","_flag$flag","_flag$flag$attributes","_flag$flag$attributes2","_flag$flag$attributes3","_graphic$graphic","_graphic$graphic$attr","_graphic$graphic$attr2","_graphic$graphic$attr3","_graphic$graphic$attr4","flag","graphic","position","orientation","scale","image","isVisibleItem","isVisible","ratio","_image$source$data$wi","_image$source$data$he","source","width","height","rotationModifier","orientationCopy","Euler","fromArray","currentAngle","MathUtils","radToDeg","z","decalRotation","newAngle","degToRad","scaleModifier","Decal","rotation","depthTest","depthWrite","polygonOffset","polygonOffsetFactor","opacity","_text$material","_text$material$attrib","_text$material$attrib2","_text$material$attrib3","_text$material$attrib4","_text$material$attrib5","_text$selectedName","_text$selectedName2","_text$selectedName2$a","_text$selectedName3","_text$decalRotation","isLuxury","material","images","length","selectedName","hasPuff","puffPrice","hasCrystals","crystalPrice","shouldNormalMap","normalMap","Texture","console","log","textIsVisible","normalScale","matRef","refreshCount","setRefreshCount","preview","cur","roughness","Vector2","geom","_jsxs","renderOrder","colorWrite","decalPosition","decalOrientation","DecalGraphic","decalScale","DecalText","setNodes","newNodes","remove","cleanNodes","prev","geometries","optionalPart","filter","flat","_p$attributes","isMesh","push","BufferGeometryUtils","models","selectedModels","Scene","forwardRef","groupRef","remountTrigger","modelRotation","useDesignStore","addingToCart","rotateY","dispose","ModelMerge","m","_m$model","Model","ModelDecals","displayName"],"sourceRoot":""}