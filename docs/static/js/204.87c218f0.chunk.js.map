{"version":3,"file":"static/js/204.87c218f0.chunk.js","mappings":"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","sources":["../node_modules/src/geometries/DecalGeometry.js","../node_modules/@react-three/drei/core/Decal.js","../node_modules/src/loaders/DRACOLoader.js","../node_modules/src/libs/MeshoptDecoder.ts","../node_modules/src/utils/BufferGeometryUtils.ts","../node_modules/src/_polyfill/constants.ts","../node_modules/src/loaders/GLTFLoader.js","../node_modules/@react-three/drei/core/useGLTF.js","../node_modules/@react-three/drei/core/useTexture.js","../node_modules/three/examples/jsm/utils/BufferGeometryUtils.js"],"sourcesContent":["import { BufferGeometry, Float32BufferAttribute, Matrix4, Vector3 } from 'three'\n\n/**\n * You can use this geometry to create a decal mesh, that serves different kinds of purposes.\n * e.g. adding unique details to models, performing dynamic visual environmental changes or covering seams.\n *\n * Constructor parameter:\n *\n * mesh  Any mesh object\n * position  Position of the decal projector\n * orientation  Orientation of the decal projector\n * size  Size of the decal projector\n *\n * reference: http://blog.wolfire.com/2009/06/how-to-project-decals/\n *\n */\n\nclass DecalGeometry extends BufferGeometry {\n  constructor(mesh, position, orientation, size) {\n    super()\n\n    // buffers\n\n    const vertices = []\n    const normals = []\n    const uvs = []\n\n    // helpers\n\n    const plane = new Vector3()\n\n    // this matrix represents the transformation of the decal projector\n\n    const projectorMatrix = new Matrix4()\n    projectorMatrix.makeRotationFromEuler(orientation)\n    projectorMatrix.setPosition(position)\n\n    const projectorMatrixInverse = new Matrix4()\n    projectorMatrixInverse.copy(projectorMatrix).invert()\n\n    // generate buffers\n\n    generate()\n\n    // build geometry\n\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3))\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3))\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2))\n\n    function generate() {\n      let i\n\n      let decalVertices = []\n\n      const vertex = new Vector3()\n      const normal = new Vector3()\n\n      // handle different geometry types\n\n      if (mesh.geometry.isGeometry === true) {\n        console.error('THREE.DecalGeometry no longer supports THREE.Geometry. Use BufferGeometry instead.')\n        return\n      }\n\n      const geometry = mesh.geometry\n\n      const positionAttribute = geometry.attributes.position\n      const normalAttribute = geometry.attributes.normal\n\n      // first, create an array of 'DecalVertex' objects\n      // three consecutive 'DecalVertex' objects represent a single face\n      //\n      // this data structure will be later used to perform the clipping\n\n      if (geometry.index !== null) {\n        // indexed BufferGeometry\n\n        const index = geometry.index\n\n        for (i = 0; i < index.count; i++) {\n          vertex.fromBufferAttribute(positionAttribute, index.getX(i))\n          normal.fromBufferAttribute(normalAttribute, index.getX(i))\n\n          pushDecalVertex(decalVertices, vertex, normal)\n        }\n      } else {\n        // non-indexed BufferGeometry\n\n        for (i = 0; i < positionAttribute.count; i++) {\n          vertex.fromBufferAttribute(positionAttribute, i)\n          normal.fromBufferAttribute(normalAttribute, i)\n\n          pushDecalVertex(decalVertices, vertex, normal)\n        }\n      }\n\n      // second, clip the geometry so that it doesn't extend out from the projector\n\n      decalVertices = clipGeometry(decalVertices, plane.set(1, 0, 0))\n      decalVertices = clipGeometry(decalVertices, plane.set(-1, 0, 0))\n      decalVertices = clipGeometry(decalVertices, plane.set(0, 1, 0))\n      decalVertices = clipGeometry(decalVertices, plane.set(0, -1, 0))\n      decalVertices = clipGeometry(decalVertices, plane.set(0, 0, 1))\n      decalVertices = clipGeometry(decalVertices, plane.set(0, 0, -1))\n\n      // third, generate final vertices, normals and uvs\n\n      for (i = 0; i < decalVertices.length; i++) {\n        const decalVertex = decalVertices[i]\n\n        // create texture coordinates (we are still in projector space)\n\n        uvs.push(0.5 + decalVertex.position.x / size.x, 0.5 + decalVertex.position.y / size.y)\n\n        // transform the vertex back to world space\n\n        decalVertex.position.applyMatrix4(projectorMatrix)\n\n        // now create vertex and normal buffer data\n\n        vertices.push(decalVertex.position.x, decalVertex.position.y, decalVertex.position.z)\n        normals.push(decalVertex.normal.x, decalVertex.normal.y, decalVertex.normal.z)\n      }\n    }\n\n    function pushDecalVertex(decalVertices, vertex, normal) {\n      // transform the vertex to world space, then to projector space\n\n      vertex.applyMatrix4(mesh.matrixWorld)\n      vertex.applyMatrix4(projectorMatrixInverse)\n\n      normal.transformDirection(mesh.matrixWorld)\n\n      decalVertices.push(new DecalVertex(vertex.clone(), normal.clone()))\n    }\n\n    function clipGeometry(inVertices, plane) {\n      const outVertices = []\n\n      const s = 0.5 * Math.abs(size.dot(plane))\n\n      // a single iteration clips one face,\n      // which consists of three consecutive 'DecalVertex' objects\n\n      for (let i = 0; i < inVertices.length; i += 3) {\n        let v1Out,\n          v2Out,\n          v3Out,\n          total = 0\n        let nV1, nV2, nV3, nV4\n\n        const d1 = inVertices[i + 0].position.dot(plane) - s\n        const d2 = inVertices[i + 1].position.dot(plane) - s\n        const d3 = inVertices[i + 2].position.dot(plane) - s\n\n        v1Out = d1 > 0\n        v2Out = d2 > 0\n        v3Out = d3 > 0\n\n        // calculate, how many vertices of the face lie outside of the clipping plane\n\n        total = (v1Out ? 1 : 0) + (v2Out ? 1 : 0) + (v3Out ? 1 : 0)\n\n        switch (total) {\n          case 0: {\n            // the entire face lies inside of the plane, no clipping needed\n\n            outVertices.push(inVertices[i])\n            outVertices.push(inVertices[i + 1])\n            outVertices.push(inVertices[i + 2])\n            break\n          }\n\n          case 1: {\n            // one vertex lies outside of the plane, perform clipping\n\n            if (v1Out) {\n              nV1 = inVertices[i + 1]\n              nV2 = inVertices[i + 2]\n              nV3 = clip(inVertices[i], nV1, plane, s)\n              nV4 = clip(inVertices[i], nV2, plane, s)\n            }\n\n            if (v2Out) {\n              nV1 = inVertices[i]\n              nV2 = inVertices[i + 2]\n              nV3 = clip(inVertices[i + 1], nV1, plane, s)\n              nV4 = clip(inVertices[i + 1], nV2, plane, s)\n\n              outVertices.push(nV3)\n              outVertices.push(nV2.clone())\n              outVertices.push(nV1.clone())\n\n              outVertices.push(nV2.clone())\n              outVertices.push(nV3.clone())\n              outVertices.push(nV4)\n              break\n            }\n\n            if (v3Out) {\n              nV1 = inVertices[i]\n              nV2 = inVertices[i + 1]\n              nV3 = clip(inVertices[i + 2], nV1, plane, s)\n              nV4 = clip(inVertices[i + 2], nV2, plane, s)\n            }\n\n            outVertices.push(nV1.clone())\n            outVertices.push(nV2.clone())\n            outVertices.push(nV3)\n\n            outVertices.push(nV4)\n            outVertices.push(nV3.clone())\n            outVertices.push(nV2.clone())\n\n            break\n          }\n\n          case 2: {\n            // two vertices lies outside of the plane, perform clipping\n\n            if (!v1Out) {\n              nV1 = inVertices[i].clone()\n              nV2 = clip(nV1, inVertices[i + 1], plane, s)\n              nV3 = clip(nV1, inVertices[i + 2], plane, s)\n              outVertices.push(nV1)\n              outVertices.push(nV2)\n              outVertices.push(nV3)\n            }\n\n            if (!v2Out) {\n              nV1 = inVertices[i + 1].clone()\n              nV2 = clip(nV1, inVertices[i + 2], plane, s)\n              nV3 = clip(nV1, inVertices[i], plane, s)\n              outVertices.push(nV1)\n              outVertices.push(nV2)\n              outVertices.push(nV3)\n            }\n\n            if (!v3Out) {\n              nV1 = inVertices[i + 2].clone()\n              nV2 = clip(nV1, inVertices[i], plane, s)\n              nV3 = clip(nV1, inVertices[i + 1], plane, s)\n              outVertices.push(nV1)\n              outVertices.push(nV2)\n              outVertices.push(nV3)\n            }\n\n            break\n          }\n\n          case 3: {\n            // the entire face lies outside of the plane, so let's discard the corresponding vertices\n\n            break\n          }\n        }\n      }\n\n      return outVertices\n    }\n\n    function clip(v0, v1, p, s) {\n      const d0 = v0.position.dot(p) - s\n      const d1 = v1.position.dot(p) - s\n\n      const s0 = d0 / (d0 - d1)\n\n      const v = new DecalVertex(\n        new Vector3(\n          v0.position.x + s0 * (v1.position.x - v0.position.x),\n          v0.position.y + s0 * (v1.position.y - v0.position.y),\n          v0.position.z + s0 * (v1.position.z - v0.position.z),\n        ),\n        new Vector3(\n          v0.normal.x + s0 * (v1.normal.x - v0.normal.x),\n          v0.normal.y + s0 * (v1.normal.y - v0.normal.y),\n          v0.normal.z + s0 * (v1.normal.z - v0.normal.z),\n        ),\n      )\n\n      // need to clip more values (texture coordinates)? do it this way:\n      // intersectpoint.value = a.value + s * ( b.value - a.value );\n\n      return v\n    }\n  }\n}\n\n// helper\n\nclass DecalVertex {\n  constructor(position, normal) {\n    this.position = position\n    this.normal = normal\n  }\n\n  clone() {\n    return new this.constructor(this.position.clone(), this.normal.clone())\n  }\n}\n\nexport { DecalGeometry, DecalVertex }\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport * as THREE from 'three';\nimport { applyProps } from '@react-three/fiber';\nimport { DecalGeometry } from 'three-stdlib';\n\nfunction isArray(vec) {\n  return Array.isArray(vec);\n}\n\nfunction vecToArray(vec = [0, 0, 0]) {\n  if (isArray(vec)) {\n    return vec;\n  } else if (vec instanceof THREE.Vector3 || vec instanceof THREE.Euler) {\n    return [vec.x, vec.y, vec.z];\n  } else {\n    return [vec, vec, vec];\n  }\n}\n\nfunction Decal({\n  debug,\n  mesh,\n  children,\n  position,\n  rotation,\n  scale,\n  ...props\n}) {\n  const ref = React.useRef(null);\n  const helper = React.useRef(null);\n  React.useLayoutEffect(() => {\n    const parent = (mesh == null ? void 0 : mesh.current) || ref.current.parent;\n    const target = ref.current;\n\n    if (!(parent instanceof THREE.Mesh)) {\n      throw new Error('Decal must have a Mesh as parent or specify its \"mesh\" prop');\n    }\n\n    const state = {\n      position: new THREE.Vector3(),\n      rotation: new THREE.Euler(),\n      scale: new THREE.Vector3(1, 1, 1)\n    };\n\n    if (parent) {\n      applyProps(state, {\n        position,\n        scale\n      }); // Zero out the parents matrix world for this operation\n\n      const matrixWorld = parent.matrixWorld.clone();\n      parent.matrixWorld.identity();\n\n      if (!rotation || typeof rotation === 'number') {\n        const o = new THREE.Object3D();\n        o.position.copy(state.position);\n        o.lookAt(parent.position);\n        if (typeof rotation === 'number') o.rotateZ(rotation);\n        applyProps(state, {\n          rotation: o.rotation\n        });\n      } else {\n        applyProps(state, {\n          rotation\n        });\n      }\n\n      target.geometry = new DecalGeometry(parent, state.position, state.rotation, state.scale);\n      if (helper.current) applyProps(helper.current, state); // Reset parents matix-world\n\n      parent.matrixWorld = matrixWorld;\n      return () => {\n        target.geometry.dispose();\n      };\n    }\n  }, [mesh, ...vecToArray(position), ...vecToArray(scale), ...vecToArray(rotation)]);\n  return /*#__PURE__*/React.createElement(\"mesh\", {\n    ref: ref\n  }, children || /*#__PURE__*/React.createElement(\"meshStandardMaterial\", _extends({\n    transparent: true,\n    polygonOffset: true,\n    polygonOffsetFactor: -10\n  }, props)), debug && /*#__PURE__*/React.createElement(\"mesh\", {\n    ref: helper\n  }, /*#__PURE__*/React.createElement(\"boxGeometry\", null), /*#__PURE__*/React.createElement(\"meshNormalMaterial\", {\n    wireframe: true\n  }), /*#__PURE__*/React.createElement(\"axesHelper\", null)));\n}\n\nexport { Decal };\n","import { BufferAttribute, BufferGeometry, FileLoader, Loader } from 'three'\n\nconst _taskCache = new WeakMap()\n\nclass DRACOLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n\n    this.decoderPath = ''\n    this.decoderConfig = {}\n    this.decoderBinary = null\n    this.decoderPending = null\n\n    this.workerLimit = 4\n    this.workerPool = []\n    this.workerNextTaskID = 1\n    this.workerSourceURL = ''\n\n    this.defaultAttributeIDs = {\n      position: 'POSITION',\n      normal: 'NORMAL',\n      color: 'COLOR',\n      uv: 'TEX_COORD',\n    }\n    this.defaultAttributeTypes = {\n      position: 'Float32Array',\n      normal: 'Float32Array',\n      color: 'Float32Array',\n      uv: 'Float32Array',\n    }\n  }\n\n  setDecoderPath(path) {\n    this.decoderPath = path\n\n    return this\n  }\n\n  setDecoderConfig(config) {\n    this.decoderConfig = config\n\n    return this\n  }\n\n  setWorkerLimit(workerLimit) {\n    this.workerLimit = workerLimit\n\n    return this\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager)\n\n    loader.setPath(this.path)\n    loader.setResponseType('arraybuffer')\n    loader.setRequestHeader(this.requestHeader)\n    loader.setWithCredentials(this.withCredentials)\n\n    loader.load(\n      url,\n      (buffer) => {\n        const taskConfig = {\n          attributeIDs: this.defaultAttributeIDs,\n          attributeTypes: this.defaultAttributeTypes,\n          useUniqueIDs: false,\n        }\n\n        this.decodeGeometry(buffer, taskConfig).then(onLoad).catch(onError)\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */\n  decodeDracoFile(buffer, callback, attributeIDs, attributeTypes) {\n    const taskConfig = {\n      attributeIDs: attributeIDs || this.defaultAttributeIDs,\n      attributeTypes: attributeTypes || this.defaultAttributeTypes,\n      useUniqueIDs: !!attributeIDs,\n    }\n\n    this.decodeGeometry(buffer, taskConfig).then(callback)\n  }\n\n  decodeGeometry(buffer, taskConfig) {\n    // TODO: For backward-compatibility, support 'attributeTypes' objects containing\n    // references (rather than names) to typed array constructors. These must be\n    // serialized before sending them to the worker.\n    for (const attribute in taskConfig.attributeTypes) {\n      const type = taskConfig.attributeTypes[attribute]\n\n      if (type.BYTES_PER_ELEMENT !== undefined) {\n        taskConfig.attributeTypes[attribute] = type.name\n      }\n    }\n\n    //\n\n    const taskKey = JSON.stringify(taskConfig)\n\n    // Check for an existing task using this buffer. A transferred buffer cannot be transferred\n    // again from this thread.\n    if (_taskCache.has(buffer)) {\n      const cachedTask = _taskCache.get(buffer)\n\n      if (cachedTask.key === taskKey) {\n        return cachedTask.promise\n      } else if (buffer.byteLength === 0) {\n        // Technically, it would be possible to wait for the previous task to complete,\n        // transfer the buffer back, and decode again with the second configuration. That\n        // is complex, and I don't know of any reason to decode a Draco buffer twice in\n        // different ways, so this is left unimplemented.\n        throw new Error(\n          'THREE.DRACOLoader: Unable to re-decode a buffer with different ' +\n            'settings. Buffer has already been transferred.',\n        )\n      }\n    }\n\n    //\n\n    let worker\n    const taskID = this.workerNextTaskID++\n    const taskCost = buffer.byteLength\n\n    // Obtain a worker and assign a task, and construct a geometry instance\n    // when the task completes.\n    const geometryPending = this._getWorker(taskID, taskCost)\n      .then((_worker) => {\n        worker = _worker\n\n        return new Promise((resolve, reject) => {\n          worker._callbacks[taskID] = { resolve, reject }\n\n          worker.postMessage({ type: 'decode', id: taskID, taskConfig, buffer }, [buffer])\n\n          // this.debug();\n        })\n      })\n      .then((message) => this._createGeometry(message.geometry))\n\n    // Remove task from the task list.\n    // Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)\n    geometryPending\n      .catch(() => true)\n      .then(() => {\n        if (worker && taskID) {\n          this._releaseTask(worker, taskID)\n\n          // this.debug();\n        }\n      })\n\n    // Cache the task result.\n    _taskCache.set(buffer, {\n      key: taskKey,\n      promise: geometryPending,\n    })\n\n    return geometryPending\n  }\n\n  _createGeometry(geometryData) {\n    const geometry = new BufferGeometry()\n\n    if (geometryData.index) {\n      geometry.setIndex(new BufferAttribute(geometryData.index.array, 1))\n    }\n\n    for (let i = 0; i < geometryData.attributes.length; i++) {\n      const attribute = geometryData.attributes[i]\n      const name = attribute.name\n      const array = attribute.array\n      const itemSize = attribute.itemSize\n\n      geometry.setAttribute(name, new BufferAttribute(array, itemSize))\n    }\n\n    return geometry\n  }\n\n  _loadLibrary(url, responseType) {\n    const loader = new FileLoader(this.manager)\n    loader.setPath(this.decoderPath)\n    loader.setResponseType(responseType)\n    loader.setWithCredentials(this.withCredentials)\n\n    return new Promise((resolve, reject) => {\n      loader.load(url, resolve, undefined, reject)\n    })\n  }\n\n  preload() {\n    this._initDecoder()\n\n    return this\n  }\n\n  _initDecoder() {\n    if (this.decoderPending) return this.decoderPending\n\n    const useJS = typeof WebAssembly !== 'object' || this.decoderConfig.type === 'js'\n    const librariesPending = []\n\n    if (useJS) {\n      librariesPending.push(this._loadLibrary('draco_decoder.js', 'text'))\n    } else {\n      librariesPending.push(this._loadLibrary('draco_wasm_wrapper.js', 'text'))\n      librariesPending.push(this._loadLibrary('draco_decoder.wasm', 'arraybuffer'))\n    }\n\n    this.decoderPending = Promise.all(librariesPending).then((libraries) => {\n      const jsContent = libraries[0]\n\n      if (!useJS) {\n        this.decoderConfig.wasmBinary = libraries[1]\n      }\n\n      const fn = DRACOWorker.toString()\n\n      const body = [\n        '/* draco decoder */',\n        jsContent,\n        '',\n        '/* worker */',\n        fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}')),\n      ].join('\\n')\n\n      this.workerSourceURL = URL.createObjectURL(new Blob([body]))\n    })\n\n    return this.decoderPending\n  }\n\n  _getWorker(taskID, taskCost) {\n    return this._initDecoder().then(() => {\n      if (this.workerPool.length < this.workerLimit) {\n        const worker = new Worker(this.workerSourceURL)\n\n        worker._callbacks = {}\n        worker._taskCosts = {}\n        worker._taskLoad = 0\n\n        worker.postMessage({ type: 'init', decoderConfig: this.decoderConfig })\n\n        worker.onmessage = function (e) {\n          const message = e.data\n\n          switch (message.type) {\n            case 'decode':\n              worker._callbacks[message.id].resolve(message)\n              break\n\n            case 'error':\n              worker._callbacks[message.id].reject(message)\n              break\n\n            default:\n              console.error('THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"')\n          }\n        }\n\n        this.workerPool.push(worker)\n      } else {\n        this.workerPool.sort(function (a, b) {\n          return a._taskLoad > b._taskLoad ? -1 : 1\n        })\n      }\n\n      const worker = this.workerPool[this.workerPool.length - 1]\n      worker._taskCosts[taskID] = taskCost\n      worker._taskLoad += taskCost\n      return worker\n    })\n  }\n\n  _releaseTask(worker, taskID) {\n    worker._taskLoad -= worker._taskCosts[taskID]\n    delete worker._callbacks[taskID]\n    delete worker._taskCosts[taskID]\n  }\n\n  debug() {\n    console.log(\n      'Task load: ',\n      this.workerPool.map((worker) => worker._taskLoad),\n    )\n  }\n\n  dispose() {\n    for (let i = 0; i < this.workerPool.length; ++i) {\n      this.workerPool[i].terminate()\n    }\n\n    this.workerPool.length = 0\n\n    return this\n  }\n}\n\n/* WEB WORKER */\n\nfunction DRACOWorker() {\n  let decoderConfig\n  let decoderPending\n\n  onmessage = function (e) {\n    const message = e.data\n\n    switch (message.type) {\n      case 'init':\n        decoderConfig = message.decoderConfig\n        decoderPending = new Promise(function (resolve /*, reject*/) {\n          decoderConfig.onModuleLoaded = function (draco) {\n            // Module is Promise-like. Wrap before resolving to avoid loop.\n            resolve({ draco: draco })\n          }\n\n          DracoDecoderModule(decoderConfig)\n        })\n        break\n\n      case 'decode':\n        const buffer = message.buffer\n        const taskConfig = message.taskConfig\n        decoderPending.then((module) => {\n          const draco = module.draco\n          const decoder = new draco.Decoder()\n          const decoderBuffer = new draco.DecoderBuffer()\n          decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength)\n\n          try {\n            const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig)\n\n            const buffers = geometry.attributes.map((attr) => attr.array.buffer)\n\n            if (geometry.index) buffers.push(geometry.index.array.buffer)\n\n            self.postMessage({ type: 'decode', id: message.id, geometry }, buffers)\n          } catch (error) {\n            console.error(error)\n\n            self.postMessage({ type: 'error', id: message.id, error: error.message })\n          } finally {\n            draco.destroy(decoderBuffer)\n            draco.destroy(decoder)\n          }\n        })\n        break\n    }\n  }\n\n  function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n    const attributeIDs = taskConfig.attributeIDs\n    const attributeTypes = taskConfig.attributeTypes\n\n    let dracoGeometry\n    let decodingStatus\n\n    const geometryType = decoder.GetEncodedGeometryType(decoderBuffer)\n\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      dracoGeometry = new draco.Mesh()\n      decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry)\n    } else if (geometryType === draco.POINT_CLOUD) {\n      dracoGeometry = new draco.PointCloud()\n      decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry)\n    } else {\n      throw new Error('THREE.DRACOLoader: Unexpected geometry type.')\n    }\n\n    if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n      throw new Error('THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg())\n    }\n\n    const geometry = { index: null, attributes: [] }\n\n    // Gather all vertex attributes.\n    for (const attributeName in attributeIDs) {\n      const attributeType = self[attributeTypes[attributeName]]\n\n      let attribute\n      let attributeID\n\n      // A Draco file may be created with default vertex attributes, whose attribute IDs\n      // are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\n      // a Draco file may contain a custom set of attributes, identified by known unique\n      // IDs. glTF files always do the latter, and `.drc` files typically do the former.\n      if (taskConfig.useUniqueIDs) {\n        attributeID = attributeIDs[attributeName]\n        attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID)\n      } else {\n        attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]])\n\n        if (attributeID === -1) continue\n\n        attribute = decoder.GetAttribute(dracoGeometry, attributeID)\n      }\n\n      geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute))\n    }\n\n    // Add index.\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      geometry.index = decodeIndex(draco, decoder, dracoGeometry)\n    }\n\n    draco.destroy(dracoGeometry)\n\n    return geometry\n  }\n\n  function decodeIndex(draco, decoder, dracoGeometry) {\n    const numFaces = dracoGeometry.num_faces()\n    const numIndices = numFaces * 3\n    const byteLength = numIndices * 4\n\n    const ptr = draco._malloc(byteLength)\n    decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr)\n    const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice()\n    draco._free(ptr)\n\n    return { array: index, itemSize: 1 }\n  }\n\n  function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n    const numComponents = attribute.num_components()\n    const numPoints = dracoGeometry.num_points()\n    const numValues = numPoints * numComponents\n    const byteLength = numValues * attributeType.BYTES_PER_ELEMENT\n    const dataType = getDracoDataType(draco, attributeType)\n\n    const ptr = draco._malloc(byteLength)\n    decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr)\n    const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice()\n    draco._free(ptr)\n\n    return {\n      name: attributeName,\n      array: array,\n      itemSize: numComponents,\n    }\n  }\n\n  function getDracoDataType(draco, attributeType) {\n    switch (attributeType) {\n      case Float32Array:\n        return draco.DT_FLOAT32\n      case Int8Array:\n        return draco.DT_INT8\n      case Int16Array:\n        return draco.DT_INT16\n      case Int32Array:\n        return draco.DT_INT32\n      case Uint8Array:\n        return draco.DT_UINT8\n      case Uint16Array:\n        return draco.DT_UINT16\n      case Uint32Array:\n        return draco.DT_UINT32\n    }\n  }\n}\n\nexport { DRACOLoader }\n","// This file is part of meshoptimizer library and is distributed under the terms of MIT License.\n// Copyright (C) 2016-2020, by Arseny Kapoulkine (arseny.kapoulkine@gmail.com)\n\ntype API = {\n  ready: Promise<void>\n  supported: boolean\n  decodeVertexBuffer: (target: Uint8Array, count: number, size: number, source: Uint8Array, filter?: string) => void\n  decodeIndexBuffer: (target: Uint8Array, count: number, size: number, source: Uint8Array) => void\n  decodeIndexSequence: (target: Uint8Array, count: number, size: number, source: Uint8Array) => void\n  decodeGltfBuffer: (\n    target: Uint8Array,\n    count: number,\n    size: number,\n    source: Uint8Array,\n    mode: string,\n    filter?: string,\n  ) => void\n}\n\nlet generated: API\n\nconst MeshoptDecoder = () => {\n  if (generated) return generated\n\n  // Built with clang version 11.0.0 (https://github.com/llvm/llvm-project.git 0160ad802e899c2922bc9b29564080c22eb0908c)\n  // Built from meshoptimizer 0.14\n  const wasm_base =\n    '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'\n  const wasm_simd =\n    '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'\n\n  // Uses bulk-memory and simd extensions\n  const detector = new Uint8Array([\n    0,\n    97,\n    115,\n    109,\n    1,\n    0,\n    0,\n    0,\n    1,\n    4,\n    1,\n    96,\n    0,\n    0,\n    3,\n    3,\n    2,\n    0,\n    0,\n    5,\n    3,\n    1,\n    0,\n    1,\n    12,\n    1,\n    0,\n    10,\n    22,\n    2,\n    12,\n    0,\n    65,\n    0,\n    65,\n    0,\n    65,\n    0,\n    252,\n    10,\n    0,\n    0,\n    11,\n    7,\n    0,\n    65,\n    0,\n    253,\n    15,\n    26,\n    11,\n  ])\n\n  // Used to unpack wasm\n  const wasmpack = new Uint8Array([\n    32,\n    0,\n    65,\n    253,\n    3,\n    1,\n    2,\n    34,\n    4,\n    106,\n    6,\n    5,\n    11,\n    8,\n    7,\n    20,\n    13,\n    33,\n    12,\n    16,\n    128,\n    9,\n    116,\n    64,\n    19,\n    113,\n    127,\n    15,\n    10,\n    21,\n    22,\n    14,\n    255,\n    66,\n    24,\n    54,\n    136,\n    107,\n    18,\n    23,\n    192,\n    26,\n    114,\n    118,\n    132,\n    17,\n    77,\n    101,\n    130,\n    144,\n    27,\n    87,\n    131,\n    44,\n    45,\n    74,\n    156,\n    154,\n    70,\n    167,\n  ])\n\n  if (typeof WebAssembly !== 'object') {\n    // This module requires WebAssembly to function\n    return {\n      supported: false,\n    }\n  }\n\n  let wasm = wasm_base\n\n  if (WebAssembly.validate(detector)) {\n    wasm = wasm_simd\n  }\n\n  let instance: any // WebAssembly.Instance\n\n  const promise = WebAssembly.instantiate(unpack(wasm), {}).then((result) => {\n    instance = result.instance\n    instance.exports.__wasm_call_ctors()\n  })\n\n  function unpack(data: string) {\n    const result = new Uint8Array(data.length)\n    for (let i = 0; i < data.length; ++i) {\n      const ch = data.charCodeAt(i)\n      result[i] = ch > 96 ? ch - 71 : ch > 64 ? ch - 65 : ch > 47 ? ch + 4 : ch > 46 ? 63 : 62\n    }\n    let write = 0\n    for (let i = 0; i < data.length; ++i) {\n      result[write++] = result[i] < 60 ? wasmpack[result[i]] : (result[i] - 60) * 64 + result[++i]\n    }\n    return result.buffer.slice(0, write)\n  }\n\n  function decode(\n    fun: Function,\n    target: Uint8Array,\n    count: number,\n    size: number,\n    source: Uint8Array,\n    filter?: Function,\n  ) {\n    const sbrk = instance.exports.sbrk\n    const count4 = (count + 3) & ~3 // pad for SIMD filter\n    const tp = sbrk(count4 * size)\n    const sp = sbrk(source.length)\n    const heap = new Uint8Array(instance.exports.memory.buffer)\n    heap.set(source, sp)\n    const res = fun(tp, count, size, sp, source.length)\n    if (res === 0 && filter) {\n      filter(tp, count4, size)\n    }\n    target.set(heap.subarray(tp, tp + count * size))\n    sbrk(tp - sbrk(0))\n    if (res !== 0) {\n      throw new Error(`Malformed buffer data: ${res}`)\n    }\n  }\n\n  const filters = {\n    // legacy index-based enums for glTF\n    0: '',\n    1: 'meshopt_decodeFilterOct',\n    2: 'meshopt_decodeFilterQuat',\n    3: 'meshopt_decodeFilterExp',\n    // string-based enums for glTF\n    NONE: '',\n    OCTAHEDRAL: 'meshopt_decodeFilterOct',\n    QUATERNION: 'meshopt_decodeFilterQuat',\n    EXPONENTIAL: 'meshopt_decodeFilterExp',\n  }\n\n  const decoders = {\n    // legacy index-based enums for glTF\n    0: 'meshopt_decodeVertexBuffer',\n    1: 'meshopt_decodeIndexBuffer',\n    2: 'meshopt_decodeIndexSequence',\n    // string-based enums for glTF\n    ATTRIBUTES: 'meshopt_decodeVertexBuffer',\n    TRIANGLES: 'meshopt_decodeIndexBuffer',\n    INDICES: 'meshopt_decodeIndexSequence',\n  }\n\n  generated = {\n    ready: promise,\n    supported: true,\n    decodeVertexBuffer(target, count, size, source, filter) {\n      decode(\n        instance.exports.meshopt_decodeVertexBuffer,\n        target,\n        count,\n        size,\n        source,\n        instance.exports[filters[filter as keyof typeof filters]],\n      )\n    },\n    decodeIndexBuffer(target, count, size, source) {\n      decode(instance.exports.meshopt_decodeIndexBuffer, target, count, size, source)\n    },\n    decodeIndexSequence(target, count, size, source) {\n      decode(instance.exports.meshopt_decodeIndexSequence, target, count, size, source)\n    },\n    decodeGltfBuffer(target, count, size, source, mode, filter) {\n      decode(\n        instance.exports[decoders[mode as keyof typeof decoders]],\n        target,\n        count,\n        size,\n        source,\n        instance.exports[filters[filter as keyof typeof filters]],\n      )\n    },\n  }\n\n  return generated\n}\n\nexport { MeshoptDecoder }\n","import {\n  BufferAttribute,\n  BufferGeometry,\n  Float32BufferAttribute,\n  InterleavedBuffer,\n  InterleavedBufferAttribute,\n  TriangleFanDrawMode,\n  TriangleStripDrawMode,\n  TrianglesDrawMode,\n  Vector3,\n  Mesh,\n  Line,\n  Points,\n  Material,\n  SkinnedMesh,\n} from 'three'\n\nimport { getWithKey } from '../types/helpers'\nimport type { TypedArrayConstructors, TypedArray } from '../types/shared'\n\n/**\n * @param  {Array<BufferGeometry>} geometries\n * @param  {Boolean} useGroups\n * @return {BufferGeometry}\n */\nexport const mergeBufferGeometries = (geometries: BufferGeometry[], useGroups?: boolean): BufferGeometry | null => {\n  const isIndexed = geometries[0].index !== null\n\n  const attributesUsed = new Set(Object.keys(geometries[0].attributes))\n  const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes))\n\n  const attributes: { [key: string]: Array<InterleavedBufferAttribute | BufferAttribute> } = {}\n  const morphAttributes: { [key: string]: Array<BufferAttribute | InterleavedBufferAttribute>[] } = {}\n\n  const morphTargetsRelative = geometries[0].morphTargetsRelative\n\n  const mergedGeometry = new BufferGeometry()\n\n  let offset = 0\n\n  geometries.forEach((geom, i) => {\n    let attributesCount = 0\n\n    // ensure that all geometries are indexed, or none\n\n    if (isIndexed !== (geom.index !== null)) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' +\n          i +\n          '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.',\n      )\n      return null\n    }\n\n    // gather attributes, exit early if they're different\n\n    for (let name in geom.attributes) {\n      if (!attributesUsed.has(name)) {\n        console.error(\n          'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' +\n            i +\n            '. All geometries must have compatible attributes; make sure \"' +\n            name +\n            '\" attribute exists among all geometries, or in none of them.',\n        )\n        return null\n      }\n\n      if (attributes[name] === undefined) {\n        attributes[name] = []\n      }\n\n      attributes[name].push(geom.attributes[name])\n\n      attributesCount++\n    }\n\n    // ensure geometries have the same number of attributes\n\n    if (attributesCount !== attributesUsed.size) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' +\n          i +\n          '. Make sure all geometries have the same number of attributes.',\n      )\n      return null\n    }\n\n    // gather morph attributes, exit early if they're different\n\n    if (morphTargetsRelative !== geom.morphTargetsRelative) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' +\n          i +\n          '. .morphTargetsRelative must be consistent throughout all geometries.',\n      )\n      return null\n    }\n\n    for (let name in geom.morphAttributes) {\n      if (!morphAttributesUsed.has(name)) {\n        console.error(\n          'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' +\n            i +\n            '.  .morphAttributes must be consistent throughout all geometries.',\n        )\n        return null\n      }\n\n      if (morphAttributes[name] === undefined) morphAttributes[name] = []\n\n      morphAttributes[name].push(geom.morphAttributes[name])\n    }\n\n    // gather .userData\n\n    mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || []\n    mergedGeometry.userData.mergedUserData.push(geom.userData)\n\n    if (useGroups) {\n      let count\n\n      if (geom.index) {\n        count = geom.index.count\n      } else if (geom.attributes.position !== undefined) {\n        count = geom.attributes.position.count\n      } else {\n        console.error(\n          'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' +\n            i +\n            '. The geometry must have either an index or a position attribute',\n        )\n        return null\n      }\n\n      mergedGeometry.addGroup(offset, count, i)\n\n      offset += count\n    }\n  })\n\n  // merge indices\n\n  if (isIndexed) {\n    let indexOffset = 0\n    const mergedIndex: number[] = []\n\n    geometries.forEach((geom) => {\n      const index = geom.index as BufferAttribute\n\n      for (let j = 0; j < index.count; ++j) {\n        mergedIndex.push(index.getX(j) + indexOffset)\n      }\n\n      indexOffset += geom.attributes.position.count\n    })\n\n    mergedGeometry.setIndex(mergedIndex)\n  }\n\n  // merge attributes\n\n  for (let name in attributes) {\n    const mergedAttribute = mergeBufferAttributes(attributes[name] as BufferAttribute[])\n\n    if (!mergedAttribute) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' attribute.',\n      )\n      return null\n    }\n\n    mergedGeometry.setAttribute(name, mergedAttribute)\n  }\n\n  // merge morph attributes\n\n  for (let name in morphAttributes) {\n    const numMorphTargets = morphAttributes[name][0].length\n\n    if (numMorphTargets === 0) break\n\n    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {}\n    mergedGeometry.morphAttributes[name] = []\n\n    for (let i = 0; i < numMorphTargets; ++i) {\n      const morphAttributesToMerge = []\n\n      for (let j = 0; j < morphAttributes[name].length; ++j) {\n        morphAttributesToMerge.push(morphAttributes[name][j][i])\n      }\n\n      const mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge as BufferAttribute[])\n\n      if (!mergedMorphAttribute) {\n        console.error(\n          'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' +\n            name +\n            ' morphAttribute.',\n        )\n        return null\n      }\n\n      mergedGeometry.morphAttributes[name].push(mergedMorphAttribute)\n    }\n  }\n\n  return mergedGeometry\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {BufferAttribute}\n */\nexport const mergeBufferAttributes = (attributes: BufferAttribute[]): BufferAttribute | null | undefined => {\n  let TypedArray: TypedArrayConstructors | undefined = undefined\n  let itemSize: number | undefined = undefined\n  let normalized: boolean | undefined = undefined\n  let arrayLength = 0\n\n  attributes.forEach((attr) => {\n    if (TypedArray === undefined) {\n      TypedArray = attr.array.constructor\n    }\n    if (TypedArray !== attr.array.constructor) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.',\n      )\n      return null\n    }\n\n    if (itemSize === undefined) itemSize = attr.itemSize\n    if (itemSize !== attr.itemSize) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.',\n      )\n      return null\n    }\n\n    if (normalized === undefined) normalized = attr.normalized\n    if (normalized !== attr.normalized) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.',\n      )\n      return null\n    }\n\n    arrayLength += attr.array.length\n  })\n\n  if (TypedArray && itemSize) {\n    // @ts-ignore this works in JS and TS is complaining but it's such a tiny thing I can live with the guilt\n    const array = new TypedArray(arrayLength)\n    let offset = 0\n\n    attributes.forEach((attr) => {\n      array.set(attr.array, offset)\n      offset += attr.array.length\n    })\n\n    return new BufferAttribute(array, itemSize, normalized)\n  }\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {Array<InterleavedBufferAttribute>}\n */\nexport const interleaveAttributes = (attributes: BufferAttribute[]): InterleavedBufferAttribute[] | null => {\n  // Interleaves the provided attributes into an InterleavedBuffer and returns\n  // a set of InterleavedBufferAttributes for each attribute\n  let TypedArray: TypedArrayConstructors | undefined = undefined\n  let arrayLength = 0\n  let stride = 0\n\n  // calculate the the length and type of the interleavedBuffer\n  for (let i = 0, l = attributes.length; i < l; ++i) {\n    const attribute = attributes[i]\n\n    if (TypedArray === undefined) TypedArray = attribute.array.constructor\n    if (TypedArray !== attribute.array.constructor) {\n      console.error('AttributeBuffers of different types cannot be interleaved')\n      return null\n    }\n\n    arrayLength += attribute.array.length\n    stride += attribute.itemSize\n  }\n\n  // Create the set of buffer attributes\n  // @ts-ignore this works in JS and TS is complaining but it's such a tiny thing I can live with the guilt\n  const interleavedBuffer = new InterleavedBuffer(new TypedArray(arrayLength), stride)\n  let offset = 0\n  const res = []\n  const getters = ['getX', 'getY', 'getZ', 'getW']\n  const setters = ['setX', 'setY', 'setZ', 'setW']\n\n  for (let j = 0, l = attributes.length; j < l; j++) {\n    const attribute = attributes[j]\n    const itemSize = attribute.itemSize\n    const count = attribute.count\n    const iba = new InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized)\n    res.push(iba)\n\n    offset += itemSize\n\n    // Move the data for each attribute into the new interleavedBuffer\n    // at the appropriate offset\n    for (let c = 0; c < count; c++) {\n      for (let k = 0; k < itemSize; k++) {\n        const set = getWithKey(iba, setters[k] as keyof InterleavedBufferAttribute) as InterleavedBufferAttribute[\n          | 'setX'\n          | 'setY'\n          | 'setZ'\n          | 'setW']\n        const get = getWithKey(attribute, getters[k] as keyof BufferAttribute) as BufferAttribute[\n          | 'getX'\n          | 'getY'\n          | 'getZ'\n          | 'getW']\n        set(c, get(c))\n      }\n    }\n  }\n\n  return res\n}\n\n/**\n * @param {Array<BufferGeometry>} geometry\n * @return {number}\n */\nexport function estimateBytesUsed(geometry: BufferGeometry): number {\n  // Return the estimated memory used by this geometry in bytes\n  // Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n  // for InterleavedBufferAttributes.\n  let mem = 0\n  for (let name in geometry.attributes) {\n    const attr = geometry.getAttribute(name)\n    mem += attr.count * attr.itemSize * (attr.array as TypedArray).BYTES_PER_ELEMENT\n  }\n\n  const indices = geometry.getIndex()\n  mem += indices ? indices.count * indices.itemSize * (indices.array as TypedArray).BYTES_PER_ELEMENT : 0\n  return mem\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} tolerance\n * @return {BufferGeometry>}\n */\nexport function mergeVertices(geometry: BufferGeometry, tolerance = 1e-4): BufferGeometry {\n  tolerance = Math.max(tolerance, Number.EPSILON)\n\n  // Generate an index buffer if the geometry doesn't have one, or optimize it\n  // if it's already available.\n  const hashToIndex: {\n    [key: string]: number\n  } = {}\n  const indices = geometry.getIndex()\n  const positions = geometry.getAttribute('position')\n  const vertexCount = indices ? indices.count : positions.count\n\n  // next value for triangle indices\n  let nextIndex = 0\n\n  // attributes and new attribute arrays\n  const attributeNames = Object.keys(geometry.attributes)\n  const attrArrays: {\n    [key: string]: []\n  } = {}\n  const morphAttrsArrays: {\n    [key: string]: Array<Array<BufferAttribute | InterleavedBufferAttribute>>\n  } = {}\n  const newIndices = []\n  const getters = ['getX', 'getY', 'getZ', 'getW']\n\n  // initialize the arrays\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i]\n\n    attrArrays[name] = []\n\n    const morphAttr = geometry.morphAttributes[name]\n    if (morphAttr) {\n      morphAttrsArrays[name] = new Array(morphAttr.length).fill(0).map(() => [])\n    }\n  }\n\n  // convert the error tolerance to an amount of decimal places to truncate to\n  const decimalShift = Math.log10(1 / tolerance)\n  const shiftMultiplier = Math.pow(10, decimalShift)\n  for (let i = 0; i < vertexCount; i++) {\n    const index = indices ? indices.getX(i) : i\n\n    // Generate a hash for the vertex attributes at the current index 'i'\n    let hash = ''\n    for (let j = 0, l = attributeNames.length; j < l; j++) {\n      const name = attributeNames[j]\n      const attribute = geometry.getAttribute(name)\n      const itemSize = attribute.itemSize\n\n      for (let k = 0; k < itemSize; k++) {\n        // double tilde truncates the decimal value\n        // @ts-ignore no\n        hash += `${~~(attribute[getters[k]](index) * shiftMultiplier)},`\n      }\n    }\n\n    // Add another reference to the vertex if it's already\n    // used by another index\n    if (hash in hashToIndex) {\n      newIndices.push(hashToIndex[hash])\n    } else {\n      // copy data to the new index in the attribute arrays\n      for (let j = 0, l = attributeNames.length; j < l; j++) {\n        const name = attributeNames[j]\n        const attribute = geometry.getAttribute(name)\n        const morphAttr = geometry.morphAttributes[name]\n        const itemSize = attribute.itemSize\n        const newarray = attrArrays[name]\n        const newMorphArrays = morphAttrsArrays[name]\n\n        for (let k = 0; k < itemSize; k++) {\n          const getterFunc = getters[k]\n          // @ts-ignore\n          newarray.push(attribute[getterFunc](index))\n\n          if (morphAttr) {\n            for (let m = 0, ml = morphAttr.length; m < ml; m++) {\n              // @ts-ignore\n              newMorphArrays[m].push(morphAttr[m][getterFunc](index))\n            }\n          }\n        }\n      }\n\n      hashToIndex[hash] = nextIndex\n      newIndices.push(nextIndex)\n      nextIndex++\n    }\n  }\n\n  // Generate typed arrays from new attribute arrays and update\n  // the attributeBuffers\n  const result = geometry.clone()\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i]\n    const oldAttribute = geometry.getAttribute(name)\n    //@ts-expect-error  something to do with functions and constructors and new\n    const buffer = new (oldAttribute.array as TypedArray).constructor(attrArrays[name])\n    const attribute = new BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized)\n\n    result.setAttribute(name, attribute)\n\n    // Update the attribute arrays\n    if (name in morphAttrsArrays) {\n      for (let j = 0; j < morphAttrsArrays[name].length; j++) {\n        const oldMorphAttribute = geometry.morphAttributes[name][j]\n        //@ts-expect-error something to do with functions and constructors and new\n        const buffer = new (oldMorphAttribute.array as TypedArray).constructor(morphAttrsArrays[name][j])\n        const morphAttribute = new BufferAttribute(buffer, oldMorphAttribute.itemSize, oldMorphAttribute.normalized)\n        result.morphAttributes[name][j] = morphAttribute\n      }\n    }\n  }\n\n  // indices\n\n  result.setIndex(newIndices)\n\n  return result\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} drawMode\n * @return {BufferGeometry}\n */\nexport function toTrianglesDrawMode(geometry: BufferGeometry, drawMode: number): BufferGeometry {\n  if (drawMode === TrianglesDrawMode) {\n    console.warn('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.')\n    return geometry\n  }\n\n  if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {\n    let index = geometry.getIndex()\n\n    // generate index if not present\n\n    if (index === null) {\n      const indices = []\n\n      const position = geometry.getAttribute('position')\n\n      if (position !== undefined) {\n        for (let i = 0; i < position.count; i++) {\n          indices.push(i)\n        }\n\n        geometry.setIndex(indices)\n        index = geometry.getIndex()\n      } else {\n        console.error(\n          'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.',\n        )\n        return geometry\n      }\n    }\n\n    //\n\n    const numberOfTriangles = (index as BufferAttribute).count - 2\n    const newIndices = []\n\n    if (index) {\n      if (drawMode === TriangleFanDrawMode) {\n        // gl.TRIANGLE_FAN\n\n        for (let i = 1; i <= numberOfTriangles; i++) {\n          newIndices.push(index.getX(0))\n          newIndices.push(index.getX(i))\n          newIndices.push(index.getX(i + 1))\n        }\n      } else {\n        // gl.TRIANGLE_STRIP\n\n        for (let i = 0; i < numberOfTriangles; i++) {\n          if (i % 2 === 0) {\n            newIndices.push(index.getX(i))\n            newIndices.push(index.getX(i + 1))\n            newIndices.push(index.getX(i + 2))\n          } else {\n            newIndices.push(index.getX(i + 2))\n            newIndices.push(index.getX(i + 1))\n            newIndices.push(index.getX(i))\n          }\n        }\n      }\n    }\n\n    if (newIndices.length / 3 !== numberOfTriangles) {\n      console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.')\n    }\n\n    // build final geometry\n\n    const newGeometry = geometry.clone()\n    newGeometry.setIndex(newIndices)\n    newGeometry.clearGroups()\n\n    return newGeometry\n  } else {\n    console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode)\n    return geometry\n  }\n}\n\n/**\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n * Helpful for Raytracing or Decals.\n * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n * @return {Object} An Object with original position/normal attributes and morphed ones.\n */\nexport type ComputedMorphedAttribute = {\n  positionAttribute: BufferAttribute | InterleavedBufferAttribute\n  normalAttribute: BufferAttribute | InterleavedBufferAttribute\n  morphedPositionAttribute: Float32BufferAttribute\n  morphedNormalAttribute: Float32BufferAttribute\n}\n\nexport function computeMorphedAttributes(object: Mesh | Line | Points): ComputedMorphedAttribute | null {\n  if (object.geometry.isBufferGeometry !== true) {\n    console.error('THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.')\n    return null\n  }\n\n  const _vA = new Vector3()\n  const _vB = new Vector3()\n  const _vC = new Vector3()\n\n  const _tempA = new Vector3()\n  const _tempB = new Vector3()\n  const _tempC = new Vector3()\n\n  const _morphA = new Vector3()\n  const _morphB = new Vector3()\n  const _morphC = new Vector3()\n\n  function _calculateMorphedAttributeData(\n    object: Mesh | Line | Points,\n    material: Material,\n    attribute: BufferAttribute | InterleavedBufferAttribute,\n    morphAttribute: (BufferAttribute | InterleavedBufferAttribute)[],\n    morphTargetsRelative: boolean,\n    a: number,\n    b: number,\n    c: number,\n    modifiedAttributeArray: Float32Array,\n  ): void {\n    _vA.fromBufferAttribute(attribute, a)\n    _vB.fromBufferAttribute(attribute, b)\n    _vC.fromBufferAttribute(attribute, c)\n\n    const morphInfluences = object.morphTargetInfluences\n\n    if (\n      // @ts-ignore\n      material.morphTargets &&\n      morphAttribute &&\n      morphInfluences\n    ) {\n      _morphA.set(0, 0, 0)\n      _morphB.set(0, 0, 0)\n      _morphC.set(0, 0, 0)\n\n      for (let i = 0, il = morphAttribute.length; i < il; i++) {\n        const influence = morphInfluences[i]\n        const morph = morphAttribute[i]\n\n        if (influence === 0) continue\n\n        _tempA.fromBufferAttribute(morph, a)\n        _tempB.fromBufferAttribute(morph, b)\n        _tempC.fromBufferAttribute(morph, c)\n\n        if (morphTargetsRelative) {\n          _morphA.addScaledVector(_tempA, influence)\n          _morphB.addScaledVector(_tempB, influence)\n          _morphC.addScaledVector(_tempC, influence)\n        } else {\n          _morphA.addScaledVector(_tempA.sub(_vA), influence)\n          _morphB.addScaledVector(_tempB.sub(_vB), influence)\n          _morphC.addScaledVector(_tempC.sub(_vC), influence)\n        }\n      }\n\n      _vA.add(_morphA)\n      _vB.add(_morphB)\n      _vC.add(_morphC)\n    }\n\n    if ((object as SkinnedMesh).isSkinnedMesh) {\n      // @ts-ignore  https://github.com/three-types/three-ts-types/issues/37\n      object.boneTransform(a, _vA)\n      // @ts-ignore  https://github.com/three-types/three-ts-types/issues/37\n      object.boneTransform(b, _vB)\n      // @ts-ignore  https://github.com/three-types/three-ts-types/issues/37\n      object.boneTransform(c, _vC)\n    }\n\n    modifiedAttributeArray[a * 3 + 0] = _vA.x\n    modifiedAttributeArray[a * 3 + 1] = _vA.y\n    modifiedAttributeArray[a * 3 + 2] = _vA.z\n    modifiedAttributeArray[b * 3 + 0] = _vB.x\n    modifiedAttributeArray[b * 3 + 1] = _vB.y\n    modifiedAttributeArray[b * 3 + 2] = _vB.z\n    modifiedAttributeArray[c * 3 + 0] = _vC.x\n    modifiedAttributeArray[c * 3 + 1] = _vC.y\n    modifiedAttributeArray[c * 3 + 2] = _vC.z\n  }\n\n  const geometry = object.geometry\n  const material = object.material\n\n  let a, b, c\n  const index = geometry.index\n  const positionAttribute = geometry.attributes.position\n  const morphPosition = geometry.morphAttributes.position\n  const morphTargetsRelative = geometry.morphTargetsRelative\n  const normalAttribute = geometry.attributes.normal\n  const morphNormal = geometry.morphAttributes.position\n\n  const groups = geometry.groups\n  const drawRange = geometry.drawRange\n  let i, j, il, jl\n  let group, groupMaterial\n  let start, end\n\n  const modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize)\n  const modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize)\n\n  if (index !== null) {\n    // indexed buffer geometry\n\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i]\n        groupMaterial = material[group.materialIndex as number]\n\n        start = Math.max(group.start, drawRange.start)\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count)\n\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = index.getX(j)\n          b = index.getX(j + 1)\n          c = index.getX(j + 2)\n\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            positionAttribute,\n            morphPosition,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedPosition,\n          )\n\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            normalAttribute,\n            morphNormal,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedNormal,\n          )\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start)\n      end = Math.min(index.count, drawRange.start + drawRange.count)\n\n      for (i = start, il = end; i < il; i += 3) {\n        a = index.getX(i)\n        b = index.getX(i + 1)\n        c = index.getX(i + 2)\n\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          positionAttribute,\n          morphPosition,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedPosition,\n        )\n\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          normalAttribute,\n          morphNormal,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedNormal,\n        )\n      }\n    }\n  } else if (positionAttribute !== undefined) {\n    // non-indexed buffer geometry\n\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i]\n        groupMaterial = material[group.materialIndex as number]\n\n        start = Math.max(group.start, drawRange.start)\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count)\n\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = j\n          b = j + 1\n          c = j + 2\n\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            positionAttribute,\n            morphPosition,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedPosition,\n          )\n\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            normalAttribute,\n            morphNormal,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedNormal,\n          )\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start)\n      end = Math.min(positionAttribute.count, drawRange.start + drawRange.count)\n\n      for (i = start, il = end; i < il; i += 3) {\n        a = i\n        b = i + 1\n        c = i + 2\n\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          positionAttribute,\n          morphPosition,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedPosition,\n        )\n\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          normalAttribute,\n          morphNormal,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedNormal,\n        )\n      }\n    }\n  }\n\n  const morphedPositionAttribute = new Float32BufferAttribute(modifiedPosition, 3)\n  const morphedNormalAttribute = new Float32BufferAttribute(modifiedNormal, 3)\n\n  return {\n    positionAttribute: positionAttribute,\n    normalAttribute: normalAttribute,\n    morphedPositionAttribute: morphedPositionAttribute,\n    morphedNormalAttribute: morphedNormalAttribute,\n  }\n}\n\n/**\n * Modifies the supplied geometry if it is non-indexed, otherwise creates a new,\n * non-indexed geometry. Returns the geometry with smooth normals everywhere except\n * faces that meet at an angle greater than the crease angle.\n *\n * Backwards compatible with code such as @react-three/drei's `<RoundedBox>`\n * which uses this method to operate on the original geometry.\n *\n * As of this writing, BufferGeometry.toNonIndexed() warns if the geometry is\n * non-indexed and returns `this`, i.e. the same geometry on which it was called:\n * `BufferGeometry is already non-indexed.`\n *\n * @param geometry\n * @param creaseAngle\n */\nexport function toCreasedNormals(geometry: BufferGeometry, creaseAngle = Math.PI / 3 /* 60 degrees */): BufferGeometry {\n  const creaseDot = Math.cos(creaseAngle)\n  const hashMultiplier = (1 + 1e-10) * 1e2\n\n  // reusable vectors\n  const verts = [new Vector3(), new Vector3(), new Vector3()]\n  const tempVec1 = new Vector3()\n  const tempVec2 = new Vector3()\n  const tempNorm = new Vector3()\n  const tempNorm2 = new Vector3()\n\n  // hashes a vector\n  function hashVertex(v: Vector3): string {\n    const x = ~~(v.x * hashMultiplier)\n    const y = ~~(v.y * hashMultiplier)\n    const z = ~~(v.z * hashMultiplier)\n    return `${x},${y},${z}`\n  }\n\n  const resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry\n  const posAttr = resultGeometry.attributes.position\n  const vertexMap: { [key: string]: Vector3[] } = {}\n\n  // find all the normals shared by commonly located vertices\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    const i3 = 3 * i\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0)\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1)\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2)\n\n    tempVec1.subVectors(c, b)\n    tempVec2.subVectors(a, b)\n\n    // add the normal to the map for all vertices\n    const normal = new Vector3().crossVectors(tempVec1, tempVec2).normalize()\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n]\n      const hash = hashVertex(vert)\n      if (!(hash in vertexMap)) {\n        vertexMap[hash] = []\n      }\n\n      vertexMap[hash].push(normal)\n    }\n  }\n\n  // average normals from all vertices that share a common location if they are within the\n  // provided crease threshold\n  const normalArray = new Float32Array(posAttr.count * 3)\n  const normAttr = new BufferAttribute(normalArray, 3, false)\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    // get the face normal for this vertex\n    const i3 = 3 * i\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0)\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1)\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2)\n\n    tempVec1.subVectors(c, b)\n    tempVec2.subVectors(a, b)\n\n    tempNorm.crossVectors(tempVec1, tempVec2).normalize()\n\n    // average all normals that meet the threshold and set the normal value\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n]\n      const hash = hashVertex(vert)\n      const otherNormals = vertexMap[hash]\n      tempNorm2.set(0, 0, 0)\n\n      for (let k = 0, lk = otherNormals.length; k < lk; k++) {\n        const otherNorm = otherNormals[k]\n        if (tempNorm.dot(otherNorm) > creaseDot) {\n          tempNorm2.add(otherNorm)\n        }\n      }\n\n      tempNorm2.normalize()\n      normAttr.setXYZ(i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z)\n    }\n  }\n\n  resultGeometry.setAttribute('normal', normAttr)\n  return resultGeometry\n}\n","import { REVISION } from 'three'\n\nexport const version = parseInt(REVISION.replace(/\\D+/g, ''))\n","import {\n  AnimationClip,\n  Bone,\n  Box3,\n  BufferAttribute,\n  BufferGeometry,\n  ClampToEdgeWrapping,\n  Color,\n  DirectionalLight,\n  DoubleSide,\n  FileLoader,\n  FrontSide,\n  Group,\n  ImageBitmapLoader,\n  InstancedMesh,\n  InterleavedBuffer,\n  InterleavedBufferAttribute,\n  Interpolant,\n  InterpolateDiscrete,\n  InterpolateLinear,\n  Line,\n  LineBasicMaterial,\n  LineLoop,\n  LineSegments,\n  LinearFilter,\n  LinearMipmapLinearFilter,\n  LinearMipmapNearestFilter,\n  Loader,\n  LoaderUtils,\n  Material,\n  MathUtils,\n  Matrix4,\n  Mesh,\n  MeshBasicMaterial,\n  MeshPhysicalMaterial,\n  MeshStandardMaterial,\n  MirroredRepeatWrapping,\n  NearestFilter,\n  NearestMipmapLinearFilter,\n  NearestMipmapNearestFilter,\n  NumberKeyframeTrack,\n  Object3D,\n  OrthographicCamera,\n  PerspectiveCamera,\n  PointLight,\n  Points,\n  PointsMaterial,\n  PropertyBinding,\n  Quaternion,\n  QuaternionKeyframeTrack,\n  RepeatWrapping,\n  Skeleton,\n  SkinnedMesh,\n  Sphere,\n  SpotLight,\n  Texture,\n  TextureLoader,\n  TriangleFanDrawMode,\n  TriangleStripDrawMode,\n  Vector2,\n  Vector3,\n  VectorKeyframeTrack,\n} from 'three'\nimport { toTrianglesDrawMode } from '../utils/BufferGeometryUtils'\nimport { version } from '../_polyfill/constants'\n\nclass GLTFLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n\n    this.dracoLoader = null\n    this.ktx2Loader = null\n    this.meshoptDecoder = null\n\n    this.pluginCallbacks = []\n\n    this.register(function (parser) {\n      return new GLTFMaterialsClearcoatExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFTextureBasisUExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFTextureWebPExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFTextureAVIFExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsSheenExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsTransmissionExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsVolumeExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsIorExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsEmissiveStrengthExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsSpecularExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsIridescenceExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsAnisotropyExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFLightsExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMeshoptCompression(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMeshGpuInstancing(parser)\n    })\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    let resourcePath\n\n    if (this.resourcePath !== '') {\n      resourcePath = this.resourcePath\n    } else if (this.path !== '') {\n      resourcePath = this.path\n    } else {\n      resourcePath = LoaderUtils.extractUrlBase(url)\n    }\n\n    // Tells the LoadingManager to track an extra item, which resolves after\n    // the model is fully loaded. This means the count of items loaded will\n    // be incorrect, but ensures manager.onLoad() does not fire early.\n    this.manager.itemStart(url)\n\n    const _onError = function (e) {\n      if (onError) {\n        onError(e)\n      } else {\n        console.error(e)\n      }\n\n      scope.manager.itemError(url)\n      scope.manager.itemEnd(url)\n    }\n\n    const loader = new FileLoader(this.manager)\n\n    loader.setPath(this.path)\n    loader.setResponseType('arraybuffer')\n    loader.setRequestHeader(this.requestHeader)\n    loader.setWithCredentials(this.withCredentials)\n\n    loader.load(\n      url,\n      function (data) {\n        try {\n          scope.parse(\n            data,\n            resourcePath,\n            function (gltf) {\n              onLoad(gltf)\n\n              scope.manager.itemEnd(url)\n            },\n            _onError,\n          )\n        } catch (e) {\n          _onError(e)\n        }\n      },\n      onProgress,\n      _onError,\n    )\n  }\n\n  setDRACOLoader(dracoLoader) {\n    this.dracoLoader = dracoLoader\n    return this\n  }\n\n  setDDSLoader() {\n    throw new Error('THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".')\n  }\n\n  setKTX2Loader(ktx2Loader) {\n    this.ktx2Loader = ktx2Loader\n    return this\n  }\n\n  setMeshoptDecoder(meshoptDecoder) {\n    this.meshoptDecoder = meshoptDecoder\n    return this\n  }\n\n  register(callback) {\n    if (this.pluginCallbacks.indexOf(callback) === -1) {\n      this.pluginCallbacks.push(callback)\n    }\n\n    return this\n  }\n\n  unregister(callback) {\n    if (this.pluginCallbacks.indexOf(callback) !== -1) {\n      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1)\n    }\n\n    return this\n  }\n\n  parse(data, path, onLoad, onError) {\n    let json\n    const extensions = {}\n    const plugins = {}\n\n    if (typeof data === 'string') {\n      json = JSON.parse(data)\n    } else if (data instanceof ArrayBuffer) {\n      const magic = LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4)))\n\n      if (magic === BINARY_EXTENSION_HEADER_MAGIC) {\n        try {\n          extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data)\n        } catch (error) {\n          if (onError) onError(error)\n          return\n        }\n\n        json = JSON.parse(extensions[EXTENSIONS.KHR_BINARY_GLTF].content)\n      } else {\n        json = JSON.parse(LoaderUtils.decodeText(new Uint8Array(data)))\n      }\n    } else {\n      json = data\n    }\n\n    if (json.asset === undefined || json.asset.version[0] < 2) {\n      if (onError) onError(new Error('THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.'))\n      return\n    }\n\n    const parser = new GLTFParser(json, {\n      path: path || this.resourcePath || '',\n      crossOrigin: this.crossOrigin,\n      requestHeader: this.requestHeader,\n      manager: this.manager,\n      ktx2Loader: this.ktx2Loader,\n      meshoptDecoder: this.meshoptDecoder,\n    })\n\n    parser.fileLoader.setRequestHeader(this.requestHeader)\n\n    for (let i = 0; i < this.pluginCallbacks.length; i++) {\n      const plugin = this.pluginCallbacks[i](parser)\n      plugins[plugin.name] = plugin\n\n      // Workaround to avoid determining as unknown extension\n      // in addUnknownExtensionsToUserData().\n      // Remove this workaround if we move all the existing\n      // extension handlers to plugin system\n      extensions[plugin.name] = true\n    }\n\n    if (json.extensionsUsed) {\n      for (let i = 0; i < json.extensionsUsed.length; ++i) {\n        const extensionName = json.extensionsUsed[i]\n        const extensionsRequired = json.extensionsRequired || []\n\n        switch (extensionName) {\n          case EXTENSIONS.KHR_MATERIALS_UNLIT:\n            extensions[extensionName] = new GLTFMaterialsUnlitExtension()\n            break\n\n          case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n            extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader)\n            break\n\n          case EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n            extensions[extensionName] = new GLTFTextureTransformExtension()\n            break\n\n          case EXTENSIONS.KHR_MESH_QUANTIZATION:\n            extensions[extensionName] = new GLTFMeshQuantizationExtension()\n            break\n\n          default:\n            if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === undefined) {\n              console.warn('THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".')\n            }\n        }\n      }\n    }\n\n    parser.setExtensions(extensions)\n    parser.setPlugins(plugins)\n    parser.parse(onLoad, onError)\n  }\n\n  parseAsync(data, path) {\n    const scope = this\n\n    return new Promise(function (resolve, reject) {\n      scope.parse(data, path, resolve, reject)\n    })\n  }\n}\n\n/* GLTFREGISTRY */\n\nfunction GLTFRegistry() {\n  let objects = {}\n\n  return {\n    get: function (key) {\n      return objects[key]\n    },\n\n    add: function (key, object) {\n      objects[key] = object\n    },\n\n    remove: function (key) {\n      delete objects[key]\n    },\n\n    removeAll: function () {\n      objects = {}\n    },\n  }\n}\n\n/*********************************/\n/********** EXTENSIONS ***********/\n/*********************************/\n\nconst EXTENSIONS = {\n  KHR_BINARY_GLTF: 'KHR_binary_glTF',\n  KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',\n  KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',\n  KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',\n  KHR_MATERIALS_IOR: 'KHR_materials_ior',\n  KHR_MATERIALS_SHEEN: 'KHR_materials_sheen',\n  KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',\n  KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',\n  KHR_MATERIALS_IRIDESCENCE: 'KHR_materials_iridescence',\n  KHR_MATERIALS_ANISOTROPY: 'KHR_materials_anisotropy',\n  KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',\n  KHR_MATERIALS_VOLUME: 'KHR_materials_volume',\n  KHR_TEXTURE_BASISU: 'KHR_texture_basisu',\n  KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',\n  KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',\n  KHR_MATERIALS_EMISSIVE_STRENGTH: 'KHR_materials_emissive_strength',\n  EXT_TEXTURE_WEBP: 'EXT_texture_webp',\n  EXT_TEXTURE_AVIF: 'EXT_texture_avif',\n  EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression',\n  EXT_MESH_GPU_INSTANCING: 'EXT_mesh_gpu_instancing',\n}\n\n/**\n * Punctual Lights Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n */\nclass GLTFLightsExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL\n\n    // Object3D instance caches\n    this.cache = { refs: {}, uses: {} }\n  }\n\n  _markDefs() {\n    const parser = this.parser\n    const nodeDefs = this.parser.json.nodes || []\n\n    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      const nodeDef = nodeDefs[nodeIndex]\n\n      if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== undefined) {\n        parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light)\n      }\n    }\n  }\n\n  _loadLight(lightIndex) {\n    const parser = this.parser\n    const cacheKey = 'light:' + lightIndex\n    let dependency = parser.cache.get(cacheKey)\n\n    if (dependency) return dependency\n\n    const json = parser.json\n    const extensions = (json.extensions && json.extensions[this.name]) || {}\n    const lightDefs = extensions.lights || []\n    const lightDef = lightDefs[lightIndex]\n    let lightNode\n\n    const color = new Color(0xffffff)\n\n    if (lightDef.color !== undefined) color.fromArray(lightDef.color)\n\n    const range = lightDef.range !== undefined ? lightDef.range : 0\n\n    switch (lightDef.type) {\n      case 'directional':\n        lightNode = new DirectionalLight(color)\n        lightNode.target.position.set(0, 0, -1)\n        lightNode.add(lightNode.target)\n        break\n\n      case 'point':\n        lightNode = new PointLight(color)\n        lightNode.distance = range\n        break\n\n      case 'spot':\n        lightNode = new SpotLight(color)\n        lightNode.distance = range\n        // Handle spotlight properties.\n        lightDef.spot = lightDef.spot || {}\n        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0\n        lightDef.spot.outerConeAngle =\n          lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0\n        lightNode.angle = lightDef.spot.outerConeAngle\n        lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle\n        lightNode.target.position.set(0, 0, -1)\n        lightNode.add(lightNode.target)\n        break\n\n      default:\n        throw new Error('THREE.GLTFLoader: Unexpected light type: ' + lightDef.type)\n    }\n\n    // Some lights (e.g. spot) default to a position other than the origin. Reset the position\n    // here, because node-level parsing will only override position if explicitly specified.\n    lightNode.position.set(0, 0, 0)\n\n    lightNode.decay = 2\n\n    assignExtrasToUserData(lightNode, lightDef)\n\n    if (lightDef.intensity !== undefined) lightNode.intensity = lightDef.intensity\n\n    lightNode.name = parser.createUniqueName(lightDef.name || 'light_' + lightIndex)\n\n    dependency = Promise.resolve(lightNode)\n\n    parser.cache.add(cacheKey, dependency)\n\n    return dependency\n  }\n\n  getDependency(type, index) {\n    if (type !== 'light') return\n\n    return this._loadLight(index)\n  }\n\n  createNodeAttachment(nodeIndex) {\n    const self = this\n    const parser = this.parser\n    const json = parser.json\n    const nodeDef = json.nodes[nodeIndex]\n    const lightDef = (nodeDef.extensions && nodeDef.extensions[this.name]) || {}\n    const lightIndex = lightDef.light\n\n    if (lightIndex === undefined) return null\n\n    return this._loadLight(lightIndex).then(function (light) {\n      return parser._getNodeRef(self.cache, lightIndex, light)\n    })\n  }\n}\n\n/**\n * Unlit Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n */\nclass GLTFMaterialsUnlitExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT\n  }\n\n  getMaterialType() {\n    return MeshBasicMaterial\n  }\n\n  extendParams(materialParams, materialDef, parser) {\n    const pending = []\n\n    materialParams.color = new Color(1.0, 1.0, 1.0)\n    materialParams.opacity = 1.0\n\n    const metallicRoughness = materialDef.pbrMetallicRoughness\n\n    if (metallicRoughness) {\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        const array = metallicRoughness.baseColorFactor\n\n        materialParams.color.fromArray(array)\n        materialParams.opacity = array[3]\n      }\n\n      if (metallicRoughness.baseColorTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture, 3001)) // sRGBEncoding\n      }\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Materials Emissive Strength Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/blob/5768b3ce0ef32bc39cdf1bef10b948586635ead3/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md\n */\nclass GLTFMaterialsEmissiveStrengthExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const emissiveStrength = materialDef.extensions[this.name].emissiveStrength\n\n    if (emissiveStrength !== undefined) {\n      materialParams.emissiveIntensity = emissiveStrength\n    }\n\n    return Promise.resolve()\n  }\n}\n\n/**\n * Clearcoat Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\n */\nclass GLTFMaterialsClearcoatExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    if (extension.clearcoatFactor !== undefined) {\n      materialParams.clearcoat = extension.clearcoatFactor\n    }\n\n    if (extension.clearcoatTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'clearcoatMap', extension.clearcoatTexture))\n    }\n\n    if (extension.clearcoatRoughnessFactor !== undefined) {\n      materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor\n    }\n\n    if (extension.clearcoatRoughnessTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture))\n    }\n\n    if (extension.clearcoatNormalTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture))\n\n      if (extension.clearcoatNormalTexture.scale !== undefined) {\n        const scale = extension.clearcoatNormalTexture.scale\n\n        materialParams.clearcoatNormalScale = new Vector2(scale, scale)\n      }\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Iridescence Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence\n */\nclass GLTFMaterialsIridescenceExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    if (extension.iridescenceFactor !== undefined) {\n      materialParams.iridescence = extension.iridescenceFactor\n    }\n\n    if (extension.iridescenceTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'iridescenceMap', extension.iridescenceTexture))\n    }\n\n    if (extension.iridescenceIor !== undefined) {\n      materialParams.iridescenceIOR = extension.iridescenceIor\n    }\n\n    if (materialParams.iridescenceThicknessRange === undefined) {\n      materialParams.iridescenceThicknessRange = [100, 400]\n    }\n\n    if (extension.iridescenceThicknessMinimum !== undefined) {\n      materialParams.iridescenceThicknessRange[0] = extension.iridescenceThicknessMinimum\n    }\n\n    if (extension.iridescenceThicknessMaximum !== undefined) {\n      materialParams.iridescenceThicknessRange[1] = extension.iridescenceThicknessMaximum\n    }\n\n    if (extension.iridescenceThicknessTexture !== undefined) {\n      pending.push(\n        parser.assignTexture(materialParams, 'iridescenceThicknessMap', extension.iridescenceThicknessTexture),\n      )\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Sheen Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen\n */\nclass GLTFMaterialsSheenExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_SHEEN\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    materialParams.sheenColor = new Color(0, 0, 0)\n    materialParams.sheenRoughness = 0\n    materialParams.sheen = 1\n\n    const extension = materialDef.extensions[this.name]\n\n    if (extension.sheenColorFactor !== undefined) {\n      materialParams.sheenColor.fromArray(extension.sheenColorFactor)\n    }\n\n    if (extension.sheenRoughnessFactor !== undefined) {\n      materialParams.sheenRoughness = extension.sheenRoughnessFactor\n    }\n\n    if (extension.sheenColorTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'sheenColorMap', extension.sheenColorTexture, 3001)) // sRGBEncoding\n    }\n\n    if (extension.sheenRoughnessTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'sheenRoughnessMap', extension.sheenRoughnessTexture))\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Transmission Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n * Draft: https://github.com/KhronosGroup/glTF/pull/1698\n */\nclass GLTFMaterialsTransmissionExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    if (extension.transmissionFactor !== undefined) {\n      materialParams.transmission = extension.transmissionFactor\n    }\n\n    if (extension.transmissionTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'transmissionMap', extension.transmissionTexture))\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Materials Volume Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\n */\nclass GLTFMaterialsVolumeExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_VOLUME\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    materialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0\n\n    if (extension.thicknessTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'thicknessMap', extension.thicknessTexture))\n    }\n\n    materialParams.attenuationDistance = extension.attenuationDistance || Infinity\n\n    const colorArray = extension.attenuationColor || [1, 1, 1]\n    materialParams.attenuationColor = new Color(colorArray[0], colorArray[1], colorArray[2])\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Materials ior Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior\n */\nclass GLTFMaterialsIorExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_IOR\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const extension = materialDef.extensions[this.name]\n\n    materialParams.ior = extension.ior !== undefined ? extension.ior : 1.5\n\n    return Promise.resolve()\n  }\n}\n\n/**\n * Materials specular Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular\n */\nclass GLTFMaterialsSpecularExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    materialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0\n\n    if (extension.specularTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'specularIntensityMap', extension.specularTexture))\n    }\n\n    const colorArray = extension.specularColorFactor || [1, 1, 1]\n    materialParams.specularColor = new Color(colorArray[0], colorArray[1], colorArray[2])\n\n    if (extension.specularColorTexture !== undefined) {\n      pending.push(\n        parser.assignTexture(materialParams, 'specularColorMap', extension.specularColorTexture, 3001), // sRGBEncoding\n      )\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Materials anisotropy Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_anisotropy\n */\nclass GLTFMaterialsAnisotropyExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    if (extension.anisotropyStrength !== undefined) {\n      materialParams.anisotropy = extension.anisotropyStrength\n    }\n\n    if (extension.anisotropyRotation !== undefined) {\n      materialParams.anisotropyRotation = extension.anisotropyRotation\n    }\n\n    if (extension.anisotropyTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'anisotropyMap', extension.anisotropyTexture))\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * BasisU Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu\n */\nclass GLTFTextureBasisUExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_TEXTURE_BASISU\n  }\n\n  loadTexture(textureIndex) {\n    const parser = this.parser\n    const json = parser.json\n\n    const textureDef = json.textures[textureIndex]\n\n    if (!textureDef.extensions || !textureDef.extensions[this.name]) {\n      return null\n    }\n\n    const extension = textureDef.extensions[this.name]\n    const loader = parser.options.ktx2Loader\n\n    if (!loader) {\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n        throw new Error('THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures')\n      } else {\n        // Assumes that the extension is optional and that a fallback texture is present\n        return null\n      }\n    }\n\n    return parser.loadTextureImage(textureIndex, extension.source, loader)\n  }\n}\n\n/**\n * WebP Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp\n */\nclass GLTFTextureWebPExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.EXT_TEXTURE_WEBP\n    this.isSupported = null\n  }\n\n  loadTexture(textureIndex) {\n    const name = this.name\n    const parser = this.parser\n    const json = parser.json\n\n    const textureDef = json.textures[textureIndex]\n\n    if (!textureDef.extensions || !textureDef.extensions[name]) {\n      return null\n    }\n\n    const extension = textureDef.extensions[name]\n    const source = json.images[extension.source]\n\n    let loader = parser.textureLoader\n    if (source.uri) {\n      const handler = parser.options.manager.getHandler(source.uri)\n      if (handler !== null) loader = handler\n    }\n\n    return this.detectSupport().then(function (isSupported) {\n      if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader)\n\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n        throw new Error('THREE.GLTFLoader: WebP required by asset but unsupported.')\n      }\n\n      // Fall back to PNG or JPEG.\n      return parser.loadTexture(textureIndex)\n    })\n  }\n\n  detectSupport() {\n    if (!this.isSupported) {\n      this.isSupported = new Promise(function (resolve) {\n        const image = new Image()\n\n        // Lossy test image. Support for lossy images doesn't guarantee support for all\n        // WebP images, unfortunately.\n        image.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA'\n\n        image.onload = image.onerror = function () {\n          resolve(image.height === 1)\n        }\n      })\n    }\n\n    return this.isSupported\n  }\n}\n\n/**\n * AVIF Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_avif\n */\nclass GLTFTextureAVIFExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.EXT_TEXTURE_AVIF\n    this.isSupported = null\n  }\n\n  loadTexture(textureIndex) {\n    const name = this.name\n    const parser = this.parser\n    const json = parser.json\n\n    const textureDef = json.textures[textureIndex]\n\n    if (!textureDef.extensions || !textureDef.extensions[name]) {\n      return null\n    }\n\n    const extension = textureDef.extensions[name]\n    const source = json.images[extension.source]\n\n    let loader = parser.textureLoader\n    if (source.uri) {\n      const handler = parser.options.manager.getHandler(source.uri)\n      if (handler !== null) loader = handler\n    }\n\n    return this.detectSupport().then(function (isSupported) {\n      if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader)\n\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n        throw new Error('THREE.GLTFLoader: AVIF required by asset but unsupported.')\n      }\n\n      // Fall back to PNG or JPEG.\n      return parser.loadTexture(textureIndex)\n    })\n  }\n\n  detectSupport() {\n    if (!this.isSupported) {\n      this.isSupported = new Promise(function (resolve) {\n        const image = new Image()\n\n        // Lossy test image.\n        image.src =\n          'data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI='\n        image.onload = image.onerror = function () {\n          resolve(image.height === 1)\n        }\n      })\n    }\n\n    return this.isSupported\n  }\n}\n\n/**\n * meshopt BufferView Compression Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression\n */\nclass GLTFMeshoptCompression {\n  constructor(parser) {\n    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION\n    this.parser = parser\n  }\n\n  loadBufferView(index) {\n    const json = this.parser.json\n    const bufferView = json.bufferViews[index]\n\n    if (bufferView.extensions && bufferView.extensions[this.name]) {\n      const extensionDef = bufferView.extensions[this.name]\n\n      const buffer = this.parser.getDependency('buffer', extensionDef.buffer)\n      const decoder = this.parser.options.meshoptDecoder\n\n      if (!decoder || !decoder.supported) {\n        if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n          throw new Error('THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files')\n        } else {\n          // Assumes that the extension is optional and that fallback buffer data is present\n          return null\n        }\n      }\n\n      return buffer.then(function (res) {\n        const byteOffset = extensionDef.byteOffset || 0\n        const byteLength = extensionDef.byteLength || 0\n\n        const count = extensionDef.count\n        const stride = extensionDef.byteStride\n\n        const source = new Uint8Array(res, byteOffset, byteLength)\n\n        if (decoder.decodeGltfBufferAsync) {\n          return decoder\n            .decodeGltfBufferAsync(count, stride, source, extensionDef.mode, extensionDef.filter)\n            .then(function (res) {\n              return res.buffer\n            })\n        } else {\n          // Support for MeshoptDecoder 0.18 or earlier, without decodeGltfBufferAsync\n          return decoder.ready.then(function () {\n            const result = new ArrayBuffer(count * stride)\n            decoder.decodeGltfBuffer(\n              new Uint8Array(result),\n              count,\n              stride,\n              source,\n              extensionDef.mode,\n              extensionDef.filter,\n            )\n            return result\n          })\n        }\n      })\n    } else {\n      return null\n    }\n  }\n}\n\n/**\n * GPU Instancing Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing\n *\n */\nclass GLTFMeshGpuInstancing {\n  constructor(parser) {\n    this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING\n    this.parser = parser\n  }\n\n  createNodeMesh(nodeIndex) {\n    const json = this.parser.json\n    const nodeDef = json.nodes[nodeIndex]\n\n    if (!nodeDef.extensions || !nodeDef.extensions[this.name] || nodeDef.mesh === undefined) {\n      return null\n    }\n\n    const meshDef = json.meshes[nodeDef.mesh]\n\n    // No Points or Lines + Instancing support yet\n\n    for (const primitive of meshDef.primitives) {\n      if (\n        primitive.mode !== WEBGL_CONSTANTS.TRIANGLES &&\n        primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP &&\n        primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN &&\n        primitive.mode !== undefined\n      ) {\n        return null\n      }\n    }\n\n    const extensionDef = nodeDef.extensions[this.name]\n    const attributesDef = extensionDef.attributes\n\n    // @TODO: Can we support InstancedMesh + SkinnedMesh?\n\n    const pending = []\n    const attributes = {}\n\n    for (const key in attributesDef) {\n      pending.push(\n        this.parser.getDependency('accessor', attributesDef[key]).then((accessor) => {\n          attributes[key] = accessor\n          return attributes[key]\n        }),\n      )\n    }\n\n    if (pending.length < 1) {\n      return null\n    }\n\n    pending.push(this.parser.createNodeMesh(nodeIndex))\n\n    return Promise.all(pending).then((results) => {\n      const nodeObject = results.pop()\n      const meshes = nodeObject.isGroup ? nodeObject.children : [nodeObject]\n      const count = results[0].count // All attribute counts should be same\n      const instancedMeshes = []\n\n      for (const mesh of meshes) {\n        // Temporal variables\n        const m = new Matrix4()\n        const p = new Vector3()\n        const q = new Quaternion()\n        const s = new Vector3(1, 1, 1)\n\n        const instancedMesh = new InstancedMesh(mesh.geometry, mesh.material, count)\n\n        for (let i = 0; i < count; i++) {\n          if (attributes.TRANSLATION) {\n            p.fromBufferAttribute(attributes.TRANSLATION, i)\n          }\n\n          if (attributes.ROTATION) {\n            q.fromBufferAttribute(attributes.ROTATION, i)\n          }\n\n          if (attributes.SCALE) {\n            s.fromBufferAttribute(attributes.SCALE, i)\n          }\n\n          instancedMesh.setMatrixAt(i, m.compose(p, q, s))\n        }\n\n        // Add instance attributes to the geometry, excluding TRS.\n        for (const attributeName in attributes) {\n          if (attributeName !== 'TRANSLATION' && attributeName !== 'ROTATION' && attributeName !== 'SCALE') {\n            mesh.geometry.setAttribute(attributeName, attributes[attributeName])\n          }\n        }\n\n        // Just in case\n        Object3D.prototype.copy.call(instancedMesh, mesh)\n\n        this.parser.assignFinalMaterial(instancedMesh)\n\n        instancedMeshes.push(instancedMesh)\n      }\n\n      if (nodeObject.isGroup) {\n        nodeObject.clear()\n\n        nodeObject.add(...instancedMeshes)\n\n        return nodeObject\n      }\n\n      return instancedMeshes[0]\n    })\n  }\n}\n\n/* BINARY EXTENSION */\nconst BINARY_EXTENSION_HEADER_MAGIC = 'glTF'\nconst BINARY_EXTENSION_HEADER_LENGTH = 12\nconst BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4e4f534a, BIN: 0x004e4942 }\n\nclass GLTFBinaryExtension {\n  constructor(data) {\n    this.name = EXTENSIONS.KHR_BINARY_GLTF\n    this.content = null\n    this.body = null\n\n    const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH)\n\n    this.header = {\n      magic: LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),\n      version: headerView.getUint32(4, true),\n      length: headerView.getUint32(8, true),\n    }\n\n    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {\n      throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.')\n    } else if (this.header.version < 2.0) {\n      throw new Error('THREE.GLTFLoader: Legacy binary file detected.')\n    }\n\n    const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH\n    const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH)\n    let chunkIndex = 0\n\n    while (chunkIndex < chunkContentsLength) {\n      const chunkLength = chunkView.getUint32(chunkIndex, true)\n      chunkIndex += 4\n\n      const chunkType = chunkView.getUint32(chunkIndex, true)\n      chunkIndex += 4\n\n      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {\n        const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength)\n        this.content = LoaderUtils.decodeText(contentArray)\n      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {\n        const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex\n        this.body = data.slice(byteOffset, byteOffset + chunkLength)\n      }\n\n      // Clients must ignore chunks with unknown types.\n\n      chunkIndex += chunkLength\n    }\n\n    if (this.content === null) {\n      throw new Error('THREE.GLTFLoader: JSON content not found.')\n    }\n  }\n}\n\n/**\n * DRACO Mesh Compression Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n */\nclass GLTFDracoMeshCompressionExtension {\n  constructor(json, dracoLoader) {\n    if (!dracoLoader) {\n      throw new Error('THREE.GLTFLoader: No DRACOLoader instance provided.')\n    }\n\n    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION\n    this.json = json\n    this.dracoLoader = dracoLoader\n    this.dracoLoader.preload()\n  }\n\n  decodePrimitive(primitive, parser) {\n    const json = this.json\n    const dracoLoader = this.dracoLoader\n    const bufferViewIndex = primitive.extensions[this.name].bufferView\n    const gltfAttributeMap = primitive.extensions[this.name].attributes\n    const threeAttributeMap = {}\n    const attributeNormalizedMap = {}\n    const attributeTypeMap = {}\n\n    for (const attributeName in gltfAttributeMap) {\n      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase()\n\n      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName]\n    }\n\n    for (const attributeName in primitive.attributes) {\n      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase()\n\n      if (gltfAttributeMap[attributeName] !== undefined) {\n        const accessorDef = json.accessors[primitive.attributes[attributeName]]\n        const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType]\n\n        attributeTypeMap[threeAttributeName] = componentType.name\n        attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true\n      }\n    }\n\n    return parser.getDependency('bufferView', bufferViewIndex).then(function (bufferView) {\n      return new Promise(function (resolve) {\n        dracoLoader.decodeDracoFile(\n          bufferView,\n          function (geometry) {\n            for (const attributeName in geometry.attributes) {\n              const attribute = geometry.attributes[attributeName]\n              const normalized = attributeNormalizedMap[attributeName]\n\n              if (normalized !== undefined) attribute.normalized = normalized\n            }\n\n            resolve(geometry)\n          },\n          threeAttributeMap,\n          attributeTypeMap,\n        )\n      })\n    })\n  }\n}\n\n/**\n * Texture Transform Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform\n */\nclass GLTFTextureTransformExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM\n  }\n\n  extendTexture(texture, transform) {\n    if (\n      (transform.texCoord === undefined || transform.texCoord === texture.channel) &&\n      transform.offset === undefined &&\n      transform.rotation === undefined &&\n      transform.scale === undefined\n    ) {\n      // See https://github.com/mrdoob/three.js/issues/21819.\n      return texture\n    }\n\n    texture = texture.clone()\n\n    if (transform.texCoord !== undefined) {\n      texture.channel = transform.texCoord\n    }\n\n    if (transform.offset !== undefined) {\n      texture.offset.fromArray(transform.offset)\n    }\n\n    if (transform.rotation !== undefined) {\n      texture.rotation = transform.rotation\n    }\n\n    if (transform.scale !== undefined) {\n      texture.repeat.fromArray(transform.scale)\n    }\n\n    texture.needsUpdate = true\n\n    return texture\n  }\n}\n\n/**\n * Mesh Quantization Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization\n */\nclass GLTFMeshQuantizationExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION\n  }\n}\n\n/*********************************/\n/********** INTERPOLATION ********/\n/*********************************/\n\n// Spline Interpolation\n// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\nclass GLTFCubicSplineInterpolant extends Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer)\n  }\n\n  copySampleValue_(index) {\n    // Copies a sample value to the result buffer. See description of glTF\n    // CUBICSPLINE values layout in interpolate_() function below.\n\n    const result = this.resultBuffer,\n      values = this.sampleValues,\n      valueSize = this.valueSize,\n      offset = index * valueSize * 3 + valueSize\n\n    for (let i = 0; i !== valueSize; i++) {\n      result[i] = values[offset + i]\n    }\n\n    return result\n  }\n\n  interpolate_(i1, t0, t, t1) {\n    const result = this.resultBuffer\n    const values = this.sampleValues\n    const stride = this.valueSize\n\n    const stride2 = stride * 2\n    const stride3 = stride * 3\n\n    const td = t1 - t0\n\n    const p = (t - t0) / td\n    const pp = p * p\n    const ppp = pp * p\n\n    const offset1 = i1 * stride3\n    const offset0 = offset1 - stride3\n\n    const s2 = -2 * ppp + 3 * pp\n    const s3 = ppp - pp\n    const s0 = 1 - s2\n    const s1 = s3 - pp + p\n\n    // Layout of keyframe output values for CUBICSPLINE animations:\n    //   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\n    for (let i = 0; i !== stride; i++) {\n      const p0 = values[offset0 + i + stride] // splineVertex_k\n      const m0 = values[offset0 + i + stride2] * td // outTangent_k * (t_k+1 - t_k)\n      const p1 = values[offset1 + i + stride] // splineVertex_k+1\n      const m1 = values[offset1 + i] * td // inTangent_k+1 * (t_k+1 - t_k)\n\n      result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1\n    }\n\n    return result\n  }\n}\n\nconst _q = new Quaternion()\n\nclass GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {\n  interpolate_(i1, t0, t, t1) {\n    const result = super.interpolate_(i1, t0, t, t1)\n\n    _q.fromArray(result).normalize().toArray(result)\n\n    return result\n  }\n}\n\n/*********************************/\n/********** INTERNALS ************/\n/*********************************/\n\n/* CONSTANTS */\n\nconst WEBGL_CONSTANTS = {\n  FLOAT: 5126,\n  //FLOAT_MAT2: 35674,\n  FLOAT_MAT3: 35675,\n  FLOAT_MAT4: 35676,\n  FLOAT_VEC2: 35664,\n  FLOAT_VEC3: 35665,\n  FLOAT_VEC4: 35666,\n  LINEAR: 9729,\n  REPEAT: 10497,\n  SAMPLER_2D: 35678,\n  POINTS: 0,\n  LINES: 1,\n  LINE_LOOP: 2,\n  LINE_STRIP: 3,\n  TRIANGLES: 4,\n  TRIANGLE_STRIP: 5,\n  TRIANGLE_FAN: 6,\n  UNSIGNED_BYTE: 5121,\n  UNSIGNED_SHORT: 5123,\n}\n\nconst WEBGL_COMPONENT_TYPES = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array,\n}\n\nconst WEBGL_FILTERS = {\n  9728: NearestFilter,\n  9729: LinearFilter,\n  9984: NearestMipmapNearestFilter,\n  9985: LinearMipmapNearestFilter,\n  9986: NearestMipmapLinearFilter,\n  9987: LinearMipmapLinearFilter,\n}\n\nconst WEBGL_WRAPPINGS = {\n  33071: ClampToEdgeWrapping,\n  33648: MirroredRepeatWrapping,\n  10497: RepeatWrapping,\n}\n\nconst WEBGL_TYPE_SIZES = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16,\n}\n\nconst ATTRIBUTES = {\n  POSITION: 'position',\n  NORMAL: 'normal',\n  TANGENT: 'tangent',\n  // uv => uv1, 4 uv channels\n  // https://github.com/mrdoob/three.js/pull/25943\n  // https://github.com/mrdoob/three.js/pull/25788\n  ...(version >= 152\n    ? {\n        TEXCOORD_0: 'uv',\n        TEXCOORD_1: 'uv1',\n        TEXCOORD_2: 'uv2',\n        TEXCOORD_3: 'uv3',\n      }\n    : {\n        TEXCOORD_0: 'uv',\n        TEXCOORD_1: 'uv2',\n      }),\n\n  COLOR_0: 'color',\n  WEIGHTS_0: 'skinWeight',\n  JOINTS_0: 'skinIndex',\n}\n\nconst PATH_PROPERTIES = {\n  scale: 'scale',\n  translation: 'position',\n  rotation: 'quaternion',\n  weights: 'morphTargetInfluences',\n}\n\nconst INTERPOLATION = {\n  CUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n  // keyframe track will be initialized with a default interpolation type, then modified.\n  LINEAR: InterpolateLinear,\n  STEP: InterpolateDiscrete,\n}\n\nconst ALPHA_MODES = {\n  OPAQUE: 'OPAQUE',\n  MASK: 'MASK',\n  BLEND: 'BLEND',\n}\n\n/**\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\n */\nfunction createDefaultMaterial(cache) {\n  if (cache['DefaultMaterial'] === undefined) {\n    cache['DefaultMaterial'] = new MeshStandardMaterial({\n      color: 0xffffff,\n      emissive: 0x000000,\n      metalness: 1,\n      roughness: 1,\n      transparent: false,\n      depthTest: true,\n      side: FrontSide,\n    })\n  }\n\n  return cache['DefaultMaterial']\n}\n\nfunction addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {\n  // Add unknown glTF extensions to an object's userData.\n\n  for (const name in objectDef.extensions) {\n    if (knownExtensions[name] === undefined) {\n      object.userData.gltfExtensions = object.userData.gltfExtensions || {}\n      object.userData.gltfExtensions[name] = objectDef.extensions[name]\n    }\n  }\n}\n\n/**\n * @param {Object3D|Material|BufferGeometry} object\n * @param {GLTF.definition} gltfDef\n */\nfunction assignExtrasToUserData(object, gltfDef) {\n  if (gltfDef.extras !== undefined) {\n    if (typeof gltfDef.extras === 'object') {\n      Object.assign(object.userData, gltfDef.extras)\n    } else {\n      console.warn('THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras)\n    }\n  }\n}\n\n/**\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\n *\n * @param {BufferGeometry} geometry\n * @param {Array<GLTF.Target>} targets\n * @param {GLTFParser} parser\n * @return {Promise<BufferGeometry>}\n */\nfunction addMorphTargets(geometry, targets, parser) {\n  let hasMorphPosition = false\n  let hasMorphNormal = false\n  let hasMorphColor = false\n\n  for (let i = 0, il = targets.length; i < il; i++) {\n    const target = targets[i]\n\n    if (target.POSITION !== undefined) hasMorphPosition = true\n    if (target.NORMAL !== undefined) hasMorphNormal = true\n    if (target.COLOR_0 !== undefined) hasMorphColor = true\n\n    if (hasMorphPosition && hasMorphNormal && hasMorphColor) break\n  }\n\n  if (!hasMorphPosition && !hasMorphNormal && !hasMorphColor) return Promise.resolve(geometry)\n\n  const pendingPositionAccessors = []\n  const pendingNormalAccessors = []\n  const pendingColorAccessors = []\n\n  for (let i = 0, il = targets.length; i < il; i++) {\n    const target = targets[i]\n\n    if (hasMorphPosition) {\n      const pendingAccessor =\n        target.POSITION !== undefined ? parser.getDependency('accessor', target.POSITION) : geometry.attributes.position\n\n      pendingPositionAccessors.push(pendingAccessor)\n    }\n\n    if (hasMorphNormal) {\n      const pendingAccessor =\n        target.NORMAL !== undefined ? parser.getDependency('accessor', target.NORMAL) : geometry.attributes.normal\n\n      pendingNormalAccessors.push(pendingAccessor)\n    }\n\n    if (hasMorphColor) {\n      const pendingAccessor =\n        target.COLOR_0 !== undefined ? parser.getDependency('accessor', target.COLOR_0) : geometry.attributes.color\n\n      pendingColorAccessors.push(pendingAccessor)\n    }\n  }\n\n  return Promise.all([\n    Promise.all(pendingPositionAccessors),\n    Promise.all(pendingNormalAccessors),\n    Promise.all(pendingColorAccessors),\n  ]).then(function (accessors) {\n    const morphPositions = accessors[0]\n    const morphNormals = accessors[1]\n    const morphColors = accessors[2]\n\n    if (hasMorphPosition) geometry.morphAttributes.position = morphPositions\n    if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals\n    if (hasMorphColor) geometry.morphAttributes.color = morphColors\n    geometry.morphTargetsRelative = true\n\n    return geometry\n  })\n}\n\n/**\n * @param {Mesh} mesh\n * @param {GLTF.Mesh} meshDef\n */\nfunction updateMorphTargets(mesh, meshDef) {\n  mesh.updateMorphTargets()\n\n  if (meshDef.weights !== undefined) {\n    for (let i = 0, il = meshDef.weights.length; i < il; i++) {\n      mesh.morphTargetInfluences[i] = meshDef.weights[i]\n    }\n  }\n\n  // .extras has user-defined data, so check that .extras.targetNames is an array.\n  if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {\n    const targetNames = meshDef.extras.targetNames\n\n    if (mesh.morphTargetInfluences.length === targetNames.length) {\n      mesh.morphTargetDictionary = {}\n\n      for (let i = 0, il = targetNames.length; i < il; i++) {\n        mesh.morphTargetDictionary[targetNames[i]] = i\n      }\n    } else {\n      console.warn('THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.')\n    }\n  }\n}\n\nfunction createPrimitiveKey(primitiveDef) {\n  let geometryKey\n\n  const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]\n\n  if (dracoExtension) {\n    geometryKey =\n      'draco:' +\n      dracoExtension.bufferView +\n      ':' +\n      dracoExtension.indices +\n      ':' +\n      createAttributesKey(dracoExtension.attributes)\n  } else {\n    geometryKey = primitiveDef.indices + ':' + createAttributesKey(primitiveDef.attributes) + ':' + primitiveDef.mode\n  }\n\n  if (primitiveDef.targets !== undefined) {\n    for (let i = 0, il = primitiveDef.targets.length; i < il; i++) {\n      geometryKey += ':' + createAttributesKey(primitiveDef.targets[i])\n    }\n  }\n\n  return geometryKey\n}\n\nfunction createAttributesKey(attributes) {\n  let attributesKey = ''\n\n  const keys = Object.keys(attributes).sort()\n\n  for (let i = 0, il = keys.length; i < il; i++) {\n    attributesKey += keys[i] + ':' + attributes[keys[i]] + ';'\n  }\n\n  return attributesKey\n}\n\nfunction getNormalizedComponentScale(constructor) {\n  // Reference:\n  // https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data\n\n  switch (constructor) {\n    case Int8Array:\n      return 1 / 127\n\n    case Uint8Array:\n      return 1 / 255\n\n    case Int16Array:\n      return 1 / 32767\n\n    case Uint16Array:\n      return 1 / 65535\n\n    default:\n      throw new Error('THREE.GLTFLoader: Unsupported normalized accessor component type.')\n  }\n}\n\nfunction getImageURIMimeType(uri) {\n  if (uri.search(/\\.jpe?g($|\\?)/i) > 0 || uri.search(/^data\\:image\\/jpeg/) === 0) return 'image/jpeg'\n  if (uri.search(/\\.webp($|\\?)/i) > 0 || uri.search(/^data\\:image\\/webp/) === 0) return 'image/webp'\n\n  return 'image/png'\n}\n\nconst _identityMatrix = new Matrix4()\n\n/* GLTF PARSER */\n\nclass GLTFParser {\n  constructor(json = {}, options = {}) {\n    this.json = json\n    this.extensions = {}\n    this.plugins = {}\n    this.options = options\n\n    // loader object cache\n    this.cache = new GLTFRegistry()\n\n    // associations between Three.js objects and glTF elements\n    this.associations = new Map()\n\n    // BufferGeometry caching\n    this.primitiveCache = {}\n\n    // Node cache\n    this.nodeCache = {}\n\n    // Object3D instance caches\n    this.meshCache = { refs: {}, uses: {} }\n    this.cameraCache = { refs: {}, uses: {} }\n    this.lightCache = { refs: {}, uses: {} }\n\n    this.sourceCache = {}\n    this.textureCache = {}\n\n    // Track node names, to ensure no duplicates\n    this.nodeNamesUsed = {}\n\n    // Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the\n    // expensive work of uploading a texture to the GPU off the main thread.\n\n    let isSafari = false\n    let isFirefox = false\n    let firefoxVersion = -1\n\n    if (typeof navigator !== 'undefined' && typeof navigator.userAgent !== 'undefined') {\n      isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === true\n      isFirefox = navigator.userAgent.indexOf('Firefox') > -1\n      firefoxVersion = isFirefox ? navigator.userAgent.match(/Firefox\\/([0-9]+)\\./)[1] : -1\n    }\n\n    if (typeof createImageBitmap === 'undefined' || isSafari || (isFirefox && firefoxVersion < 98)) {\n      this.textureLoader = new TextureLoader(this.options.manager)\n    } else {\n      this.textureLoader = new ImageBitmapLoader(this.options.manager)\n    }\n\n    this.textureLoader.setCrossOrigin(this.options.crossOrigin)\n    this.textureLoader.setRequestHeader(this.options.requestHeader)\n\n    this.fileLoader = new FileLoader(this.options.manager)\n    this.fileLoader.setResponseType('arraybuffer')\n\n    if (this.options.crossOrigin === 'use-credentials') {\n      this.fileLoader.setWithCredentials(true)\n    }\n  }\n\n  setExtensions(extensions) {\n    this.extensions = extensions\n  }\n\n  setPlugins(plugins) {\n    this.plugins = plugins\n  }\n\n  parse(onLoad, onError) {\n    const parser = this\n    const json = this.json\n    const extensions = this.extensions\n\n    // Clear the loader cache\n    this.cache.removeAll()\n    this.nodeCache = {}\n\n    // Mark the special nodes/meshes in json for efficient parse\n    this._invokeAll(function (ext) {\n      return ext._markDefs && ext._markDefs()\n    })\n\n    Promise.all(\n      this._invokeAll(function (ext) {\n        return ext.beforeRoot && ext.beforeRoot()\n      }),\n    )\n      .then(function () {\n        return Promise.all([\n          parser.getDependencies('scene'),\n          parser.getDependencies('animation'),\n          parser.getDependencies('camera'),\n        ])\n      })\n      .then(function (dependencies) {\n        const result = {\n          scene: dependencies[0][json.scene || 0],\n          scenes: dependencies[0],\n          animations: dependencies[1],\n          cameras: dependencies[2],\n          asset: json.asset,\n          parser: parser,\n          userData: {},\n        }\n\n        addUnknownExtensionsToUserData(extensions, result, json)\n\n        assignExtrasToUserData(result, json)\n\n        Promise.all(\n          parser._invokeAll(function (ext) {\n            return ext.afterRoot && ext.afterRoot(result)\n          }),\n        ).then(function () {\n          onLoad(result)\n        })\n      })\n      .catch(onError)\n  }\n\n  /**\n   * Marks the special nodes/meshes in json for efficient parse.\n   */\n  _markDefs() {\n    const nodeDefs = this.json.nodes || []\n    const skinDefs = this.json.skins || []\n    const meshDefs = this.json.meshes || []\n\n    // Nothing in the node definition indicates whether it is a Bone or an\n    // Object3D. Use the skins' joint references to mark bones.\n    for (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {\n      const joints = skinDefs[skinIndex].joints\n\n      for (let i = 0, il = joints.length; i < il; i++) {\n        nodeDefs[joints[i]].isBone = true\n      }\n    }\n\n    // Iterate over all nodes, marking references to shared resources,\n    // as well as skeleton joints.\n    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      const nodeDef = nodeDefs[nodeIndex]\n\n      if (nodeDef.mesh !== undefined) {\n        this._addNodeRef(this.meshCache, nodeDef.mesh)\n\n        // Nothing in the mesh definition indicates whether it is\n        // a SkinnedMesh or Mesh. Use the node's mesh reference\n        // to mark SkinnedMesh if node has skin.\n        if (nodeDef.skin !== undefined) {\n          meshDefs[nodeDef.mesh].isSkinnedMesh = true\n        }\n      }\n\n      if (nodeDef.camera !== undefined) {\n        this._addNodeRef(this.cameraCache, nodeDef.camera)\n      }\n    }\n  }\n\n  /**\n   * Counts references to shared node / Object3D resources. These resources\n   * can be reused, or \"instantiated\", at multiple nodes in the scene\n   * hierarchy. Mesh, Camera, and Light instances are instantiated and must\n   * be marked. Non-scenegraph resources (like Materials, Geometries, and\n   * Textures) can be reused directly and are not marked here.\n   *\n   * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n   */\n  _addNodeRef(cache, index) {\n    if (index === undefined) return\n\n    if (cache.refs[index] === undefined) {\n      cache.refs[index] = cache.uses[index] = 0\n    }\n\n    cache.refs[index]++\n  }\n\n  /** Returns a reference to a shared resource, cloning it if necessary. */\n  _getNodeRef(cache, index, object) {\n    if (cache.refs[index] <= 1) return object\n\n    const ref = object.clone()\n\n    // Propagates mappings to the cloned object, prevents mappings on the\n    // original object from being lost.\n    const updateMappings = (original, clone) => {\n      const mappings = this.associations.get(original)\n      if (mappings != null) {\n        this.associations.set(clone, mappings)\n      }\n\n      for (const [i, child] of original.children.entries()) {\n        updateMappings(child, clone.children[i])\n      }\n    }\n\n    updateMappings(object, ref)\n\n    ref.name += '_instance_' + cache.uses[index]++\n\n    return ref\n  }\n\n  _invokeOne(func) {\n    const extensions = Object.values(this.plugins)\n    extensions.push(this)\n\n    for (let i = 0; i < extensions.length; i++) {\n      const result = func(extensions[i])\n\n      if (result) return result\n    }\n\n    return null\n  }\n\n  _invokeAll(func) {\n    const extensions = Object.values(this.plugins)\n    extensions.unshift(this)\n\n    const pending = []\n\n    for (let i = 0; i < extensions.length; i++) {\n      const result = func(extensions[i])\n\n      if (result) pending.push(result)\n    }\n\n    return pending\n  }\n\n  /**\n   * Requests the specified dependency asynchronously, with caching.\n   * @param {string} type\n   * @param {number} index\n   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\n   */\n  getDependency(type, index) {\n    const cacheKey = type + ':' + index\n    let dependency = this.cache.get(cacheKey)\n\n    if (!dependency) {\n      switch (type) {\n        case 'scene':\n          dependency = this.loadScene(index)\n          break\n\n        case 'node':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadNode && ext.loadNode(index)\n          })\n          break\n\n        case 'mesh':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadMesh && ext.loadMesh(index)\n          })\n          break\n\n        case 'accessor':\n          dependency = this.loadAccessor(index)\n          break\n\n        case 'bufferView':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadBufferView && ext.loadBufferView(index)\n          })\n          break\n\n        case 'buffer':\n          dependency = this.loadBuffer(index)\n          break\n\n        case 'material':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadMaterial && ext.loadMaterial(index)\n          })\n          break\n\n        case 'texture':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadTexture && ext.loadTexture(index)\n          })\n          break\n\n        case 'skin':\n          dependency = this.loadSkin(index)\n          break\n\n        case 'animation':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadAnimation && ext.loadAnimation(index)\n          })\n          break\n\n        case 'camera':\n          dependency = this.loadCamera(index)\n          break\n\n        default:\n          dependency = this._invokeOne(function (ext) {\n            return ext != this && ext.getDependency && ext.getDependency(type, index)\n          })\n\n          if (!dependency) {\n            throw new Error('Unknown type: ' + type)\n          }\n\n          break\n      }\n\n      this.cache.add(cacheKey, dependency)\n    }\n\n    return dependency\n  }\n\n  /**\n   * Requests all dependencies of the specified type asynchronously, with caching.\n   * @param {string} type\n   * @return {Promise<Array<Object>>}\n   */\n  getDependencies(type) {\n    let dependencies = this.cache.get(type)\n\n    if (!dependencies) {\n      const parser = this\n      const defs = this.json[type + (type === 'mesh' ? 'es' : 's')] || []\n\n      dependencies = Promise.all(\n        defs.map(function (def, index) {\n          return parser.getDependency(type, index)\n        }),\n      )\n\n      this.cache.add(type, dependencies)\n    }\n\n    return dependencies\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n  loadBuffer(bufferIndex) {\n    const bufferDef = this.json.buffers[bufferIndex]\n    const loader = this.fileLoader\n\n    if (bufferDef.type && bufferDef.type !== 'arraybuffer') {\n      throw new Error('THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.')\n    }\n\n    // If present, GLB container is required to be the first buffer.\n    if (bufferDef.uri === undefined && bufferIndex === 0) {\n      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body)\n    }\n\n    const options = this.options\n\n    return new Promise(function (resolve, reject) {\n      loader.load(LoaderUtils.resolveURL(bufferDef.uri, options.path), resolve, undefined, function () {\n        reject(new Error('THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".'))\n      })\n    })\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferViewIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n  loadBufferView(bufferViewIndex) {\n    const bufferViewDef = this.json.bufferViews[bufferViewIndex]\n\n    return this.getDependency('buffer', bufferViewDef.buffer).then(function (buffer) {\n      const byteLength = bufferViewDef.byteLength || 0\n      const byteOffset = bufferViewDef.byteOffset || 0\n      return buffer.slice(byteOffset, byteOffset + byteLength)\n    })\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n   * @param {number} accessorIndex\n   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\n   */\n  loadAccessor(accessorIndex) {\n    const parser = this\n    const json = this.json\n\n    const accessorDef = this.json.accessors[accessorIndex]\n\n    if (accessorDef.bufferView === undefined && accessorDef.sparse === undefined) {\n      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type]\n      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType]\n      const normalized = accessorDef.normalized === true\n\n      const array = new TypedArray(accessorDef.count * itemSize)\n      return Promise.resolve(new BufferAttribute(array, itemSize, normalized))\n    }\n\n    const pendingBufferViews = []\n\n    if (accessorDef.bufferView !== undefined) {\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.bufferView))\n    } else {\n      pendingBufferViews.push(null)\n    }\n\n    if (accessorDef.sparse !== undefined) {\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.indices.bufferView))\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.values.bufferView))\n    }\n\n    return Promise.all(pendingBufferViews).then(function (bufferViews) {\n      const bufferView = bufferViews[0]\n\n      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type]\n      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType]\n\n      // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\n      const elementBytes = TypedArray.BYTES_PER_ELEMENT\n      const itemBytes = elementBytes * itemSize\n      const byteOffset = accessorDef.byteOffset || 0\n      const byteStride =\n        accessorDef.bufferView !== undefined ? json.bufferViews[accessorDef.bufferView].byteStride : undefined\n      const normalized = accessorDef.normalized === true\n      let array, bufferAttribute\n\n      // The buffer is not interleaved if the stride is the item size in bytes.\n      if (byteStride && byteStride !== itemBytes) {\n        // Each \"slice\" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer\n        // This makes sure that IBA.count reflects accessor.count properly\n        const ibSlice = Math.floor(byteOffset / byteStride)\n        const ibCacheKey =\n          'InterleavedBuffer:' +\n          accessorDef.bufferView +\n          ':' +\n          accessorDef.componentType +\n          ':' +\n          ibSlice +\n          ':' +\n          accessorDef.count\n        let ib = parser.cache.get(ibCacheKey)\n\n        if (!ib) {\n          array = new TypedArray(bufferView, ibSlice * byteStride, (accessorDef.count * byteStride) / elementBytes)\n\n          // Integer parameters to IB/IBA are in array elements, not bytes.\n          ib = new InterleavedBuffer(array, byteStride / elementBytes)\n\n          parser.cache.add(ibCacheKey, ib)\n        }\n\n        bufferAttribute = new InterleavedBufferAttribute(\n          ib,\n          itemSize,\n          (byteOffset % byteStride) / elementBytes,\n          normalized,\n        )\n      } else {\n        if (bufferView === null) {\n          array = new TypedArray(accessorDef.count * itemSize)\n        } else {\n          array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize)\n        }\n\n        bufferAttribute = new BufferAttribute(array, itemSize, normalized)\n      }\n\n      // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\n      if (accessorDef.sparse !== undefined) {\n        const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR\n        const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType]\n\n        const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0\n        const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0\n\n        const sparseIndices = new TypedArrayIndices(\n          bufferViews[1],\n          byteOffsetIndices,\n          accessorDef.sparse.count * itemSizeIndices,\n        )\n        const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize)\n\n        if (bufferView !== null) {\n          // Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\n          bufferAttribute = new BufferAttribute(\n            bufferAttribute.array.slice(),\n            bufferAttribute.itemSize,\n            bufferAttribute.normalized,\n          )\n        }\n\n        for (let i = 0, il = sparseIndices.length; i < il; i++) {\n          const index = sparseIndices[i]\n\n          bufferAttribute.setX(index, sparseValues[i * itemSize])\n          if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1])\n          if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2])\n          if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3])\n          if (itemSize >= 5) throw new Error('THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.')\n        }\n      }\n\n      return bufferAttribute\n    })\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n   * @param {number} textureIndex\n   * @return {Promise<THREE.Texture|null>}\n   */\n  loadTexture(textureIndex) {\n    const json = this.json\n    const options = this.options\n    const textureDef = json.textures[textureIndex]\n    const sourceIndex = textureDef.source\n    const sourceDef = json.images[sourceIndex]\n\n    let loader = this.textureLoader\n\n    if (sourceDef.uri) {\n      const handler = options.manager.getHandler(sourceDef.uri)\n      if (handler !== null) loader = handler\n    }\n\n    return this.loadTextureImage(textureIndex, sourceIndex, loader)\n  }\n\n  loadTextureImage(textureIndex, sourceIndex, loader) {\n    const parser = this\n    const json = this.json\n\n    const textureDef = json.textures[textureIndex]\n    const sourceDef = json.images[sourceIndex]\n\n    const cacheKey = (sourceDef.uri || sourceDef.bufferView) + ':' + textureDef.sampler\n\n    if (this.textureCache[cacheKey]) {\n      // See https://github.com/mrdoob/three.js/issues/21559.\n      return this.textureCache[cacheKey]\n    }\n\n    const promise = this.loadImageSource(sourceIndex, loader)\n      .then(function (texture) {\n        texture.flipY = false\n\n        texture.name = textureDef.name || sourceDef.name || ''\n\n        if (\n          texture.name === '' &&\n          typeof sourceDef.uri === 'string' &&\n          sourceDef.uri.startsWith('data:image/') === false\n        ) {\n          texture.name = sourceDef.uri\n        }\n\n        const samplers = json.samplers || {}\n        const sampler = samplers[textureDef.sampler] || {}\n\n        texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter\n        texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter\n        texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping\n        texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping\n\n        parser.associations.set(texture, { textures: textureIndex })\n\n        return texture\n      })\n      .catch(function () {\n        return null\n      })\n\n    this.textureCache[cacheKey] = promise\n\n    return promise\n  }\n\n  loadImageSource(sourceIndex, loader) {\n    const parser = this\n    const json = this.json\n    const options = this.options\n\n    if (this.sourceCache[sourceIndex] !== undefined) {\n      return this.sourceCache[sourceIndex].then((texture) => texture.clone())\n    }\n\n    const sourceDef = json.images[sourceIndex]\n\n    const URL = self.URL || self.webkitURL\n\n    let sourceURI = sourceDef.uri || ''\n    let isObjectURL = false\n\n    if (sourceDef.bufferView !== undefined) {\n      // Load binary image data from bufferView, if provided.\n\n      sourceURI = parser.getDependency('bufferView', sourceDef.bufferView).then(function (bufferView) {\n        isObjectURL = true\n        const blob = new Blob([bufferView], { type: sourceDef.mimeType })\n        sourceURI = URL.createObjectURL(blob)\n        return sourceURI\n      })\n    } else if (sourceDef.uri === undefined) {\n      throw new Error('THREE.GLTFLoader: Image ' + sourceIndex + ' is missing URI and bufferView')\n    }\n\n    const promise = Promise.resolve(sourceURI)\n      .then(function (sourceURI) {\n        return new Promise(function (resolve, reject) {\n          let onLoad = resolve\n\n          if (loader.isImageBitmapLoader === true) {\n            onLoad = function (imageBitmap) {\n              const texture = new Texture(imageBitmap)\n              texture.needsUpdate = true\n\n              resolve(texture)\n            }\n          }\n\n          loader.load(LoaderUtils.resolveURL(sourceURI, options.path), onLoad, undefined, reject)\n        })\n      })\n      .then(function (texture) {\n        // Clean up resources and configure Texture.\n\n        if (isObjectURL === true) {\n          URL.revokeObjectURL(sourceURI)\n        }\n\n        texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType(sourceDef.uri)\n\n        return texture\n      })\n      .catch(function (error) {\n        console.error(\"THREE.GLTFLoader: Couldn't load texture\", sourceURI)\n        throw error\n      })\n\n    this.sourceCache[sourceIndex] = promise\n    return promise\n  }\n\n  /**\n   * Asynchronously assigns a texture to the given material parameters.\n   * @param {Object} materialParams\n   * @param {string} mapName\n   * @param {Object} mapDef\n   * @return {Promise<Texture>}\n   */\n  assignTexture(materialParams, mapName, mapDef, encoding) {\n    const parser = this\n\n    return this.getDependency('texture', mapDef.index).then(function (texture) {\n      if (!texture) return null\n\n      if (mapDef.texCoord !== undefined && mapDef.texCoord > 0) {\n        texture = texture.clone()\n        texture.channel = mapDef.texCoord\n      }\n\n      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {\n        const transform =\n          mapDef.extensions !== undefined ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : undefined\n\n        if (transform) {\n          const gltfReference = parser.associations.get(texture)\n          texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform)\n          parser.associations.set(texture, gltfReference)\n        }\n      }\n\n      if (encoding !== undefined) {\n        if ('colorSpace' in texture) texture.colorSpace = encoding === 3001 ? 'srgb' : 'srgb-linear'\n        else texture.encoding = encoding\n      }\n\n      materialParams[mapName] = texture\n\n      return texture\n    })\n  }\n\n  /**\n   * Assigns final material to a Mesh, Line, or Points instance. The instance\n   * already has a material (generated from the glTF material options alone)\n   * but reuse of the same glTF material may require multiple threejs materials\n   * to accommodate different primitive types, defines, etc. New materials will\n   * be created if necessary, and reused from a cache.\n   * @param  {Object3D} mesh Mesh, Line, or Points instance.\n   */\n  assignFinalMaterial(mesh) {\n    const geometry = mesh.geometry\n    let material = mesh.material\n\n    const useDerivativeTangents = geometry.attributes.tangent === undefined\n    const useVertexColors = geometry.attributes.color !== undefined\n    const useFlatShading = geometry.attributes.normal === undefined\n\n    if (mesh.isPoints) {\n      const cacheKey = 'PointsMaterial:' + material.uuid\n\n      let pointsMaterial = this.cache.get(cacheKey)\n\n      if (!pointsMaterial) {\n        pointsMaterial = new PointsMaterial()\n        Material.prototype.copy.call(pointsMaterial, material)\n        pointsMaterial.color.copy(material.color)\n        pointsMaterial.map = material.map\n        pointsMaterial.sizeAttenuation = false // glTF spec says points should be 1px\n\n        this.cache.add(cacheKey, pointsMaterial)\n      }\n\n      material = pointsMaterial\n    } else if (mesh.isLine) {\n      const cacheKey = 'LineBasicMaterial:' + material.uuid\n\n      let lineMaterial = this.cache.get(cacheKey)\n\n      if (!lineMaterial) {\n        lineMaterial = new LineBasicMaterial()\n        Material.prototype.copy.call(lineMaterial, material)\n        lineMaterial.color.copy(material.color)\n        lineMaterial.map = material.map\n\n        this.cache.add(cacheKey, lineMaterial)\n      }\n\n      material = lineMaterial\n    }\n\n    // Clone the material if it will be modified\n    if (useDerivativeTangents || useVertexColors || useFlatShading) {\n      let cacheKey = 'ClonedMaterial:' + material.uuid + ':'\n\n      if (useDerivativeTangents) cacheKey += 'derivative-tangents:'\n      if (useVertexColors) cacheKey += 'vertex-colors:'\n      if (useFlatShading) cacheKey += 'flat-shading:'\n\n      let cachedMaterial = this.cache.get(cacheKey)\n\n      if (!cachedMaterial) {\n        cachedMaterial = material.clone()\n\n        if (useVertexColors) cachedMaterial.vertexColors = true\n        if (useFlatShading) cachedMaterial.flatShading = true\n\n        if (useDerivativeTangents) {\n          // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n          if (cachedMaterial.normalScale) cachedMaterial.normalScale.y *= -1\n          if (cachedMaterial.clearcoatNormalScale) cachedMaterial.clearcoatNormalScale.y *= -1\n        }\n\n        this.cache.add(cacheKey, cachedMaterial)\n\n        this.associations.set(cachedMaterial, this.associations.get(material))\n      }\n\n      material = cachedMaterial\n    }\n\n    mesh.material = material\n  }\n\n  getMaterialType(/* materialIndex */) {\n    return MeshStandardMaterial\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n   * @param {number} materialIndex\n   * @return {Promise<Material>}\n   */\n  loadMaterial(materialIndex) {\n    const parser = this\n    const json = this.json\n    const extensions = this.extensions\n    const materialDef = json.materials[materialIndex]\n\n    let materialType\n    const materialParams = {}\n    const materialExtensions = materialDef.extensions || {}\n\n    const pending = []\n\n    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {\n      const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT]\n      materialType = kmuExtension.getMaterialType()\n      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser))\n    } else {\n      // Specification:\n      // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\n\n      const metallicRoughness = materialDef.pbrMetallicRoughness || {}\n\n      materialParams.color = new Color(1.0, 1.0, 1.0)\n      materialParams.opacity = 1.0\n\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        const array = metallicRoughness.baseColorFactor\n\n        materialParams.color.fromArray(array)\n        materialParams.opacity = array[3]\n      }\n\n      if (metallicRoughness.baseColorTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture, 3001)) // sRGBEncoding\n      }\n\n      materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0\n      materialParams.roughness =\n        metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0\n\n      if (metallicRoughness.metallicRoughnessTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture))\n        pending.push(parser.assignTexture(materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture))\n      }\n\n      materialType = this._invokeOne(function (ext) {\n        return ext.getMaterialType && ext.getMaterialType(materialIndex)\n      })\n\n      pending.push(\n        Promise.all(\n          this._invokeAll(function (ext) {\n            return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams)\n          }),\n        ),\n      )\n    }\n\n    if (materialDef.doubleSided === true) {\n      materialParams.side = DoubleSide\n    }\n\n    const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE\n\n    if (alphaMode === ALPHA_MODES.BLEND) {\n      materialParams.transparent = true\n\n      // See: https://github.com/mrdoob/three.js/issues/17706\n      materialParams.depthWrite = false\n    } else {\n      materialParams.transparent = false\n\n      if (alphaMode === ALPHA_MODES.MASK) {\n        materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5\n      }\n    }\n\n    if (materialDef.normalTexture !== undefined && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, 'normalMap', materialDef.normalTexture))\n\n      materialParams.normalScale = new Vector2(1, 1)\n\n      if (materialDef.normalTexture.scale !== undefined) {\n        const scale = materialDef.normalTexture.scale\n\n        materialParams.normalScale.set(scale, scale)\n      }\n    }\n\n    if (materialDef.occlusionTexture !== undefined && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, 'aoMap', materialDef.occlusionTexture))\n\n      if (materialDef.occlusionTexture.strength !== undefined) {\n        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength\n      }\n    }\n\n    if (materialDef.emissiveFactor !== undefined && materialType !== MeshBasicMaterial) {\n      materialParams.emissive = new Color().fromArray(materialDef.emissiveFactor)\n    }\n\n    if (materialDef.emissiveTexture !== undefined && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, 'emissiveMap', materialDef.emissiveTexture, 3001)) // sRGBEncoding\n    }\n\n    return Promise.all(pending).then(function () {\n      const material = new materialType(materialParams)\n\n      if (materialDef.name) material.name = materialDef.name\n\n      assignExtrasToUserData(material, materialDef)\n\n      parser.associations.set(material, { materials: materialIndex })\n\n      if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef)\n\n      return material\n    })\n  }\n\n  /** When Object3D instances are targeted by animation, they need unique names. */\n  createUniqueName(originalName) {\n    const sanitizedName = PropertyBinding.sanitizeNodeName(originalName || '')\n\n    if (sanitizedName in this.nodeNamesUsed) {\n      return sanitizedName + '_' + ++this.nodeNamesUsed[sanitizedName]\n    } else {\n      this.nodeNamesUsed[sanitizedName] = 0\n\n      return sanitizedName\n    }\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n   *\n   * Creates BufferGeometries from primitives.\n   *\n   * @param {Array<GLTF.Primitive>} primitives\n   * @return {Promise<Array<BufferGeometry>>}\n   */\n  loadGeometries(primitives) {\n    const parser = this\n    const extensions = this.extensions\n    const cache = this.primitiveCache\n\n    function createDracoPrimitive(primitive) {\n      return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]\n        .decodePrimitive(primitive, parser)\n        .then(function (geometry) {\n          return addPrimitiveAttributes(geometry, primitive, parser)\n        })\n    }\n\n    const pending = []\n\n    for (let i = 0, il = primitives.length; i < il; i++) {\n      const primitive = primitives[i]\n      const cacheKey = createPrimitiveKey(primitive)\n\n      // See if we've already created this geometry\n      const cached = cache[cacheKey]\n\n      if (cached) {\n        // Use the cached geometry if it exists\n        pending.push(cached.promise)\n      } else {\n        let geometryPromise\n\n        if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {\n          // Use DRACO geometry if available\n          geometryPromise = createDracoPrimitive(primitive)\n        } else {\n          // Otherwise create a new geometry\n          geometryPromise = addPrimitiveAttributes(new BufferGeometry(), primitive, parser)\n        }\n\n        // Cache this geometry\n        cache[cacheKey] = { primitive: primitive, promise: geometryPromise }\n\n        pending.push(geometryPromise)\n      }\n    }\n\n    return Promise.all(pending)\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n   * @param {number} meshIndex\n   * @return {Promise<Group|Mesh|SkinnedMesh>}\n   */\n  loadMesh(meshIndex) {\n    const parser = this\n    const json = this.json\n    const extensions = this.extensions\n\n    const meshDef = json.meshes[meshIndex]\n    const primitives = meshDef.primitives\n\n    const pending = []\n\n    for (let i = 0, il = primitives.length; i < il; i++) {\n      const material =\n        primitives[i].material === undefined\n          ? createDefaultMaterial(this.cache)\n          : this.getDependency('material', primitives[i].material)\n\n      pending.push(material)\n    }\n\n    pending.push(parser.loadGeometries(primitives))\n\n    return Promise.all(pending).then(function (results) {\n      const materials = results.slice(0, results.length - 1)\n      const geometries = results[results.length - 1]\n\n      const meshes = []\n\n      for (let i = 0, il = geometries.length; i < il; i++) {\n        const geometry = geometries[i]\n        const primitive = primitives[i]\n\n        // 1. create Mesh\n\n        let mesh\n\n        const material = materials[i]\n\n        if (\n          primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||\n          primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||\n          primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||\n          primitive.mode === undefined\n        ) {\n          // .isSkinnedMesh isn't in glTF spec. See ._markDefs()\n          mesh = meshDef.isSkinnedMesh === true ? new SkinnedMesh(geometry, material) : new Mesh(geometry, material)\n\n          if (mesh.isSkinnedMesh === true) {\n            // normalize skin weights to fix malformed assets (see #15319)\n            mesh.normalizeSkinWeights()\n          }\n\n          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {\n            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleStripDrawMode)\n          } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {\n            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleFanDrawMode)\n          }\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {\n          mesh = new LineSegments(geometry, material)\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {\n          mesh = new Line(geometry, material)\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {\n          mesh = new LineLoop(geometry, material)\n        } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {\n          mesh = new Points(geometry, material)\n        } else {\n          throw new Error('THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode)\n        }\n\n        if (Object.keys(mesh.geometry.morphAttributes).length > 0) {\n          updateMorphTargets(mesh, meshDef)\n        }\n\n        mesh.name = parser.createUniqueName(meshDef.name || 'mesh_' + meshIndex)\n\n        assignExtrasToUserData(mesh, meshDef)\n\n        if (primitive.extensions) addUnknownExtensionsToUserData(extensions, mesh, primitive)\n\n        parser.assignFinalMaterial(mesh)\n\n        meshes.push(mesh)\n      }\n\n      for (let i = 0, il = meshes.length; i < il; i++) {\n        parser.associations.set(meshes[i], {\n          meshes: meshIndex,\n          primitives: i,\n        })\n      }\n\n      if (meshes.length === 1) {\n        if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, meshes[0], meshDef)\n\n        return meshes[0]\n      }\n\n      const group = new Group()\n\n      if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, group, meshDef)\n\n      parser.associations.set(group, { meshes: meshIndex })\n\n      for (let i = 0, il = meshes.length; i < il; i++) {\n        group.add(meshes[i])\n      }\n\n      return group\n    })\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n   * @param {number} cameraIndex\n   * @return {Promise<THREE.Camera>}\n   */\n  loadCamera(cameraIndex) {\n    let camera\n    const cameraDef = this.json.cameras[cameraIndex]\n    const params = cameraDef[cameraDef.type]\n\n    if (!params) {\n      console.warn('THREE.GLTFLoader: Missing camera parameters.')\n      return\n    }\n\n    if (cameraDef.type === 'perspective') {\n      camera = new PerspectiveCamera(\n        MathUtils.radToDeg(params.yfov),\n        params.aspectRatio || 1,\n        params.znear || 1,\n        params.zfar || 2e6,\n      )\n    } else if (cameraDef.type === 'orthographic') {\n      camera = new OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar)\n    }\n\n    if (cameraDef.name) camera.name = this.createUniqueName(cameraDef.name)\n\n    assignExtrasToUserData(camera, cameraDef)\n\n    return Promise.resolve(camera)\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n   * @param {number} skinIndex\n   * @return {Promise<Skeleton>}\n   */\n  loadSkin(skinIndex) {\n    const skinDef = this.json.skins[skinIndex]\n\n    const pending = []\n\n    for (let i = 0, il = skinDef.joints.length; i < il; i++) {\n      pending.push(this._loadNodeShallow(skinDef.joints[i]))\n    }\n\n    if (skinDef.inverseBindMatrices !== undefined) {\n      pending.push(this.getDependency('accessor', skinDef.inverseBindMatrices))\n    } else {\n      pending.push(null)\n    }\n\n    return Promise.all(pending).then(function (results) {\n      const inverseBindMatrices = results.pop()\n      const jointNodes = results\n\n      // Note that bones (joint nodes) may or may not be in the\n      // scene graph at this time.\n\n      const bones = []\n      const boneInverses = []\n\n      for (let i = 0, il = jointNodes.length; i < il; i++) {\n        const jointNode = jointNodes[i]\n\n        if (jointNode) {\n          bones.push(jointNode)\n\n          const mat = new Matrix4()\n\n          if (inverseBindMatrices !== null) {\n            mat.fromArray(inverseBindMatrices.array, i * 16)\n          }\n\n          boneInverses.push(mat)\n        } else {\n          console.warn('THREE.GLTFLoader: Joint \"%s\" could not be found.', skinDef.joints[i])\n        }\n      }\n\n      return new Skeleton(bones, boneInverses)\n    })\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n   * @param {number} animationIndex\n   * @return {Promise<AnimationClip>}\n   */\n  loadAnimation(animationIndex) {\n    const json = this.json\n\n    const animationDef = json.animations[animationIndex]\n    const animationName = animationDef.name ? animationDef.name : 'animation_' + animationIndex\n\n    const pendingNodes = []\n    const pendingInputAccessors = []\n    const pendingOutputAccessors = []\n    const pendingSamplers = []\n    const pendingTargets = []\n\n    for (let i = 0, il = animationDef.channels.length; i < il; i++) {\n      const channel = animationDef.channels[i]\n      const sampler = animationDef.samplers[channel.sampler]\n      const target = channel.target\n      const name = target.node\n      const input = animationDef.parameters !== undefined ? animationDef.parameters[sampler.input] : sampler.input\n      const output = animationDef.parameters !== undefined ? animationDef.parameters[sampler.output] : sampler.output\n\n      if (target.node === undefined) continue\n\n      pendingNodes.push(this.getDependency('node', name))\n      pendingInputAccessors.push(this.getDependency('accessor', input))\n      pendingOutputAccessors.push(this.getDependency('accessor', output))\n      pendingSamplers.push(sampler)\n      pendingTargets.push(target)\n    }\n\n    return Promise.all([\n      Promise.all(pendingNodes),\n      Promise.all(pendingInputAccessors),\n      Promise.all(pendingOutputAccessors),\n      Promise.all(pendingSamplers),\n      Promise.all(pendingTargets),\n    ]).then(function (dependencies) {\n      const nodes = dependencies[0]\n      const inputAccessors = dependencies[1]\n      const outputAccessors = dependencies[2]\n      const samplers = dependencies[3]\n      const targets = dependencies[4]\n\n      const tracks = []\n\n      for (let i = 0, il = nodes.length; i < il; i++) {\n        const node = nodes[i]\n        const inputAccessor = inputAccessors[i]\n        const outputAccessor = outputAccessors[i]\n        const sampler = samplers[i]\n        const target = targets[i]\n\n        if (node === undefined) continue\n\n        node.updateMatrix()\n\n        let TypedKeyframeTrack\n\n        switch (PATH_PROPERTIES[target.path]) {\n          case PATH_PROPERTIES.weights:\n            TypedKeyframeTrack = NumberKeyframeTrack\n            break\n\n          case PATH_PROPERTIES.rotation:\n            TypedKeyframeTrack = QuaternionKeyframeTrack\n            break\n\n          case PATH_PROPERTIES.position:\n          case PATH_PROPERTIES.scale:\n          default:\n            TypedKeyframeTrack = VectorKeyframeTrack\n            break\n        }\n\n        const targetName = node.name ? node.name : node.uuid\n\n        const interpolation =\n          sampler.interpolation !== undefined ? INTERPOLATION[sampler.interpolation] : InterpolateLinear\n\n        const targetNames = []\n\n        if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {\n          node.traverse(function (object) {\n            if (object.morphTargetInfluences) {\n              targetNames.push(object.name ? object.name : object.uuid)\n            }\n          })\n        } else {\n          targetNames.push(targetName)\n        }\n\n        let outputArray = outputAccessor.array\n\n        if (outputAccessor.normalized) {\n          const scale = getNormalizedComponentScale(outputArray.constructor)\n          const scaled = new Float32Array(outputArray.length)\n\n          for (let j = 0, jl = outputArray.length; j < jl; j++) {\n            scaled[j] = outputArray[j] * scale\n          }\n\n          outputArray = scaled\n        }\n\n        for (let j = 0, jl = targetNames.length; j < jl; j++) {\n          const track = new TypedKeyframeTrack(\n            targetNames[j] + '.' + PATH_PROPERTIES[target.path],\n            inputAccessor.array,\n            outputArray,\n            interpolation,\n          )\n\n          // Override interpolation with custom factory method.\n          if (sampler.interpolation === 'CUBICSPLINE') {\n            track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {\n              // A CUBICSPLINE keyframe in glTF has three output values for each input value,\n              // representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\n              // must be divided by three to get the interpolant's sampleSize argument.\n\n              const interpolantType =\n                this instanceof QuaternionKeyframeTrack\n                  ? GLTFCubicSplineQuaternionInterpolant\n                  : GLTFCubicSplineInterpolant\n\n              return new interpolantType(this.times, this.values, this.getValueSize() / 3, result)\n            }\n\n            // Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.\n            track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true\n          }\n\n          tracks.push(track)\n        }\n      }\n\n      return new AnimationClip(animationName, undefined, tracks)\n    })\n  }\n\n  createNodeMesh(nodeIndex) {\n    const json = this.json\n    const parser = this\n    const nodeDef = json.nodes[nodeIndex]\n\n    if (nodeDef.mesh === undefined) return null\n\n    return parser.getDependency('mesh', nodeDef.mesh).then(function (mesh) {\n      const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh)\n\n      // if weights are provided on the node, override weights on the mesh.\n      if (nodeDef.weights !== undefined) {\n        node.traverse(function (o) {\n          if (!o.isMesh) return\n\n          for (let i = 0, il = nodeDef.weights.length; i < il; i++) {\n            o.morphTargetInfluences[i] = nodeDef.weights[i]\n          }\n        })\n      }\n\n      return node\n    })\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n   * @param {number} nodeIndex\n   * @return {Promise<Object3D>}\n   */\n  loadNode(nodeIndex) {\n    const json = this.json\n    const parser = this\n\n    const nodeDef = json.nodes[nodeIndex]\n\n    const nodePending = parser._loadNodeShallow(nodeIndex)\n\n    const childPending = []\n    const childrenDef = nodeDef.children || []\n\n    for (let i = 0, il = childrenDef.length; i < il; i++) {\n      childPending.push(parser.getDependency('node', childrenDef[i]))\n    }\n\n    const skeletonPending =\n      nodeDef.skin === undefined ? Promise.resolve(null) : parser.getDependency('skin', nodeDef.skin)\n\n    return Promise.all([nodePending, Promise.all(childPending), skeletonPending]).then(function (results) {\n      const node = results[0]\n      const children = results[1]\n      const skeleton = results[2]\n\n      if (skeleton !== null) {\n        // This full traverse should be fine because\n        // child glTF nodes have not been added to this node yet.\n        node.traverse(function (mesh) {\n          if (!mesh.isSkinnedMesh) return\n\n          mesh.bind(skeleton, _identityMatrix)\n        })\n      }\n\n      for (let i = 0, il = children.length; i < il; i++) {\n        node.add(children[i])\n      }\n\n      return node\n    })\n  }\n\n  // ._loadNodeShallow() parses a single node.\n  // skin and child nodes are created and added in .loadNode() (no '_' prefix).\n  _loadNodeShallow(nodeIndex) {\n    const json = this.json\n    const extensions = this.extensions\n    const parser = this\n\n    // This method is called from .loadNode() and .loadSkin().\n    // Cache a node to avoid duplication.\n\n    if (this.nodeCache[nodeIndex] !== undefined) {\n      return this.nodeCache[nodeIndex]\n    }\n\n    const nodeDef = json.nodes[nodeIndex]\n\n    // reserve node's name before its dependencies, so the root has the intended name.\n    const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : ''\n\n    const pending = []\n\n    const meshPromise = parser._invokeOne(function (ext) {\n      return ext.createNodeMesh && ext.createNodeMesh(nodeIndex)\n    })\n\n    if (meshPromise) {\n      pending.push(meshPromise)\n    }\n\n    if (nodeDef.camera !== undefined) {\n      pending.push(\n        parser.getDependency('camera', nodeDef.camera).then(function (camera) {\n          return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera)\n        }),\n      )\n    }\n\n    parser\n      ._invokeAll(function (ext) {\n        return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex)\n      })\n      .forEach(function (promise) {\n        pending.push(promise)\n      })\n\n    this.nodeCache[nodeIndex] = Promise.all(pending).then(function (objects) {\n      let node\n\n      // .isBone isn't in glTF spec. See ._markDefs\n      if (nodeDef.isBone === true) {\n        node = new Bone()\n      } else if (objects.length > 1) {\n        node = new Group()\n      } else if (objects.length === 1) {\n        node = objects[0]\n      } else {\n        node = new Object3D()\n      }\n\n      if (node !== objects[0]) {\n        for (let i = 0, il = objects.length; i < il; i++) {\n          node.add(objects[i])\n        }\n      }\n\n      if (nodeDef.name) {\n        node.userData.name = nodeDef.name\n        node.name = nodeName\n      }\n\n      assignExtrasToUserData(node, nodeDef)\n\n      if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef)\n\n      if (nodeDef.matrix !== undefined) {\n        const matrix = new Matrix4()\n        matrix.fromArray(nodeDef.matrix)\n        node.applyMatrix4(matrix)\n      } else {\n        if (nodeDef.translation !== undefined) {\n          node.position.fromArray(nodeDef.translation)\n        }\n\n        if (nodeDef.rotation !== undefined) {\n          node.quaternion.fromArray(nodeDef.rotation)\n        }\n\n        if (nodeDef.scale !== undefined) {\n          node.scale.fromArray(nodeDef.scale)\n        }\n      }\n\n      if (!parser.associations.has(node)) {\n        parser.associations.set(node, {})\n      }\n\n      parser.associations.get(node).nodes = nodeIndex\n\n      return node\n    })\n\n    return this.nodeCache[nodeIndex]\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n   * @param {number} sceneIndex\n   * @return {Promise<Group>}\n   */\n  loadScene(sceneIndex) {\n    const extensions = this.extensions\n    const sceneDef = this.json.scenes[sceneIndex]\n    const parser = this\n\n    // Loader returns Group, not Scene.\n    // See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172\n    const scene = new Group()\n    if (sceneDef.name) scene.name = parser.createUniqueName(sceneDef.name)\n\n    assignExtrasToUserData(scene, sceneDef)\n\n    if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef)\n\n    const nodeIds = sceneDef.nodes || []\n\n    const pending = []\n\n    for (let i = 0, il = nodeIds.length; i < il; i++) {\n      pending.push(parser.getDependency('node', nodeIds[i]))\n    }\n\n    return Promise.all(pending).then(function (nodes) {\n      for (let i = 0, il = nodes.length; i < il; i++) {\n        scene.add(nodes[i])\n      }\n\n      // Removes dangling associations, associations that reference a node that\n      // didn't make it into the scene.\n      const reduceAssociations = (node) => {\n        const reducedAssociations = new Map()\n\n        for (const [key, value] of parser.associations) {\n          if (key instanceof Material || key instanceof Texture) {\n            reducedAssociations.set(key, value)\n          }\n        }\n\n        node.traverse((node) => {\n          const mappings = parser.associations.get(node)\n\n          if (mappings != null) {\n            reducedAssociations.set(node, mappings)\n          }\n        })\n\n        return reducedAssociations\n      }\n\n      parser.associations = reduceAssociations(scene)\n\n      return scene\n    })\n  }\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {GLTF.Primitive} primitiveDef\n * @param {GLTFParser} parser\n */\nfunction computeBounds(geometry, primitiveDef, parser) {\n  const attributes = primitiveDef.attributes\n\n  const box = new Box3()\n\n  if (attributes.POSITION !== undefined) {\n    const accessor = parser.json.accessors[attributes.POSITION]\n\n    const min = accessor.min\n    const max = accessor.max\n\n    // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n    if (min !== undefined && max !== undefined) {\n      box.set(new Vector3(min[0], min[1], min[2]), new Vector3(max[0], max[1], max[2]))\n\n      if (accessor.normalized) {\n        const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType])\n        box.min.multiplyScalar(boxScale)\n        box.max.multiplyScalar(boxScale)\n      }\n    } else {\n      console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.')\n\n      return\n    }\n  } else {\n    return\n  }\n\n  const targets = primitiveDef.targets\n\n  if (targets !== undefined) {\n    const maxDisplacement = new Vector3()\n    const vector = new Vector3()\n\n    for (let i = 0, il = targets.length; i < il; i++) {\n      const target = targets[i]\n\n      if (target.POSITION !== undefined) {\n        const accessor = parser.json.accessors[target.POSITION]\n        const min = accessor.min\n        const max = accessor.max\n\n        // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n        if (min !== undefined && max !== undefined) {\n          // we need to get max of absolute components because target weight is [-1,1]\n          vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])))\n          vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])))\n          vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])))\n\n          if (accessor.normalized) {\n            const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType])\n            vector.multiplyScalar(boxScale)\n          }\n\n          // Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative\n          // to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets\n          // are used to implement key-frame animations and as such only two are active at a time - this results in very large\n          // boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.\n          maxDisplacement.max(vector)\n        } else {\n          console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.')\n        }\n      }\n    }\n\n    // As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.\n    box.expandByVector(maxDisplacement)\n  }\n\n  geometry.boundingBox = box\n\n  const sphere = new Sphere()\n\n  box.getCenter(sphere.center)\n  sphere.radius = box.min.distanceTo(box.max) / 2\n\n  geometry.boundingSphere = sphere\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {GLTF.Primitive} primitiveDef\n * @param {GLTFParser} parser\n * @return {Promise<BufferGeometry>}\n */\nfunction addPrimitiveAttributes(geometry, primitiveDef, parser) {\n  const attributes = primitiveDef.attributes\n\n  const pending = []\n\n  function assignAttributeAccessor(accessorIndex, attributeName) {\n    return parser.getDependency('accessor', accessorIndex).then(function (accessor) {\n      geometry.setAttribute(attributeName, accessor)\n    })\n  }\n\n  for (const gltfAttributeName in attributes) {\n    const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase()\n\n    // Skip attributes already provided by e.g. Draco extension.\n    if (threeAttributeName in geometry.attributes) continue\n\n    pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName))\n  }\n\n  if (primitiveDef.indices !== undefined && !geometry.index) {\n    const accessor = parser.getDependency('accessor', primitiveDef.indices).then(function (accessor) {\n      geometry.setIndex(accessor)\n    })\n\n    pending.push(accessor)\n  }\n\n  assignExtrasToUserData(geometry, primitiveDef)\n\n  computeBounds(geometry, primitiveDef, parser)\n\n  return Promise.all(pending).then(function () {\n    return primitiveDef.targets !== undefined ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry\n  })\n}\n\nexport { GLTFLoader }\n","import { GLTFLoader, DRACOLoader, MeshoptDecoder } from 'three-stdlib';\nimport { useLoader } from '@react-three/fiber';\n\n// @ts-ignore\nlet dracoLoader = null;\n\nfunction extensions(useDraco, useMeshopt, extendLoader) {\n  return loader => {\n    if (extendLoader) {\n      extendLoader(loader);\n    }\n\n    if (useDraco) {\n      if (!dracoLoader) {\n        dracoLoader = new DRACOLoader();\n      }\n\n      dracoLoader.setDecoderPath(typeof useDraco === 'string' ? useDraco : 'https://www.gstatic.com/draco/versioned/decoders/1.4.3/');\n      loader.setDRACOLoader(dracoLoader);\n    }\n\n    if (useMeshopt) {\n      loader.setMeshoptDecoder(typeof MeshoptDecoder === 'function' ? MeshoptDecoder() : MeshoptDecoder);\n    }\n  };\n}\n\nfunction useGLTF(path, useDraco = true, useMeshOpt = true, extendLoader) {\n  const gltf = useLoader(GLTFLoader, path, extensions(useDraco, useMeshOpt, extendLoader));\n  return gltf;\n}\n\nuseGLTF.preload = (path, useDraco = true, useMeshOpt = true, extendLoader) => useLoader.preload(GLTFLoader, path, extensions(useDraco, useMeshOpt, extendLoader));\n\nuseGLTF.clear = input => useLoader.clear(GLTFLoader, input);\n\nexport { useGLTF };\n","import { TextureLoader } from 'three';\nimport { useThree, useLoader } from '@react-three/fiber';\nimport { useLayoutEffect, useEffect } from 'react';\n\nconst IsObject = url => url === Object(url) && !Array.isArray(url) && typeof url !== 'function';\nfunction useTexture(input, onLoad) {\n  const gl = useThree(state => state.gl);\n  const textures = useLoader(TextureLoader, IsObject(input) ? Object.values(input) : input);\n  useLayoutEffect(() => {\n    onLoad == null ? void 0 : onLoad(textures);\n  }, [onLoad]); // https://github.com/mrdoob/three.js/issues/22696\n  // Upload the texture to the GPU immediately instead of waiting for the first render\n\n  useEffect(() => {\n    const array = Array.isArray(textures) ? textures : [textures];\n    array.forEach(gl.initTexture);\n  }, [gl, textures]);\n\n  if (IsObject(input)) {\n    const keys = Object.keys(input);\n    const keyed = {};\n    keys.forEach(key => Object.assign(keyed, {\n      [key]: textures[keys.indexOf(key)]\n    }));\n    return keyed;\n  } else {\n    return textures;\n  }\n}\n\nuseTexture.preload = url => useLoader.preload(TextureLoader, url);\n\nuseTexture.clear = input => useLoader.clear(TextureLoader, input);\n\nexport { IsObject, useTexture };\n","import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tMathUtils,\n\tTriangleFanDrawMode,\n\tTriangleStripDrawMode,\n\tTrianglesDrawMode,\n\tVector3,\n} from 'three';\n\nfunction computeTangents() {\n\n\tthrow new Error( 'BufferGeometryUtils: computeTangents renamed to computeMikkTSpaceTangents.' );\n\n}\n\nfunction computeMikkTSpaceTangents( geometry, MikkTSpace, negateSign = true ) {\n\n\tif ( ! MikkTSpace || ! MikkTSpace.isReady ) {\n\n\t\tthrow new Error( 'BufferGeometryUtils: Initialized MikkTSpace library required.' );\n\n\t}\n\n\tif ( ! geometry.hasAttribute( 'position' ) || ! geometry.hasAttribute( 'normal' ) || ! geometry.hasAttribute( 'uv' ) ) {\n\n\t\tthrow new Error( 'BufferGeometryUtils: Tangents require \"position\", \"normal\", and \"uv\" attributes.' );\n\n\t}\n\n\tfunction getAttributeArray( attribute ) {\n\n\t\tif ( attribute.normalized || attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconst srcArray = attribute.isInterleavedBufferAttribute ? attribute.data.array : attribute.array;\n\t\t\tconst dstArray = new Float32Array( attribute.getCount() * attribute.itemSize );\n\n\t\t\tfor ( let i = 0, j = 0; i < attribute.getCount(); i ++ ) {\n\n\t\t\t\tdstArray[ j ++ ] = MathUtils.denormalize( attribute.getX( i ), srcArray );\n\t\t\t\tdstArray[ j ++ ] = MathUtils.denormalize( attribute.getY( i ), srcArray );\n\n\t\t\t\tif ( attribute.itemSize > 2 ) {\n\n\t\t\t\t\tdstArray[ j ++ ] = MathUtils.denormalize( attribute.getZ( i ), srcArray );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn dstArray;\n\n\t\t}\n\n\t\tif ( attribute.array instanceof Float32Array ) {\n\n\t\t\treturn attribute.array;\n\n\t\t}\n\n\t\treturn new Float32Array( attribute.array );\n\n\t}\n\n\t// MikkTSpace algorithm requires non-indexed input.\n\n\tconst _geometry = geometry.index ? geometry.toNonIndexed() : geometry;\n\n\t// Compute vertex tangents.\n\n\tconst tangents = MikkTSpace.generateTangents(\n\n\t\tgetAttributeArray( _geometry.attributes.position ),\n\t\tgetAttributeArray( _geometry.attributes.normal ),\n\t\tgetAttributeArray( _geometry.attributes.uv )\n\n\t);\n\n\t// Texture coordinate convention of glTF differs from the apparent\n\t// default of the MikkTSpace library; .w component must be flipped.\n\n\tif ( negateSign ) {\n\n\t\tfor ( let i = 3; i < tangents.length; i += 4 ) {\n\n\t\t\ttangents[ i ] *= - 1;\n\n\t\t}\n\n\t}\n\n\t//\n\n\t_geometry.setAttribute( 'tangent', new BufferAttribute( tangents, 4 ) );\n\n\tif ( geometry !== _geometry ) {\n\n\t\tgeometry.copy( _geometry )\n\n\t}\n\n\treturn geometry;\n\n}\n\n/**\n * @param  {Array<BufferGeometry>} geometries\n * @param  {Boolean} useGroups\n * @return {BufferGeometry}\n */\nfunction mergeBufferGeometries( geometries, useGroups = false ) {\n\n\tconst isIndexed = geometries[ 0 ].index !== null;\n\n\tconst attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\n\tconst morphAttributesUsed = new Set( Object.keys( geometries[ 0 ].morphAttributes ) );\n\n\tconst attributes = {};\n\tconst morphAttributes = {};\n\n\tconst morphTargetsRelative = geometries[ 0 ].morphTargetsRelative;\n\n\tconst mergedGeometry = new BufferGeometry();\n\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\tconst geometry = geometries[ i ];\n\t\tlet attributesCount = 0;\n\n\t\t// ensure that all geometries are indexed, or none\n\n\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather attributes, exit early if they're different\n\n\t\tfor ( const name in geometry.attributes ) {\n\n\t\t\tif ( ! attributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( attributes[ name ] === undefined ) attributes[ name ] = [];\n\n\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\n\n\t\t\tattributesCount ++;\n\n\t\t}\n\n\t\t// ensure geometries have the same number of attributes\n\n\t\tif ( attributesCount !== attributesUsed.size ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather morph attributes, exit early if they're different\n\n\t\tif ( morphTargetsRelative !== geometry.morphTargetsRelative ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tfor ( const name in geometry.morphAttributes ) {\n\n\t\t\tif ( ! morphAttributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( morphAttributes[ name ] === undefined ) morphAttributes[ name ] = [];\n\n\t\t\tmorphAttributes[ name ].push( geometry.morphAttributes[ name ] );\n\n\t\t}\n\n\t\t// gather .userData\n\n\t\tmergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n\t\tmergedGeometry.userData.mergedUserData.push( geometry.userData );\n\n\t\tif ( useGroups ) {\n\n\t\t\tlet count;\n\n\t\t\tif ( isIndexed ) {\n\n\t\t\t\tcount = geometry.index.count;\n\n\t\t\t} else if ( geometry.attributes.position !== undefined ) {\n\n\t\t\t\tcount = geometry.attributes.position.count;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.addGroup( offset, count, i );\n\n\t\t\toffset += count;\n\n\t\t}\n\n\t}\n\n\t// merge indices\n\n\tif ( isIndexed ) {\n\n\t\tlet indexOffset = 0;\n\t\tconst mergedIndex = [];\n\n\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\tconst index = geometries[ i ].index;\n\n\t\t\tfor ( let j = 0; j < index.count; ++ j ) {\n\n\t\t\t\tmergedIndex.push( index.getX( j ) + indexOffset );\n\n\t\t\t}\n\n\t\t\tindexOffset += geometries[ i ].attributes.position.count;\n\n\t\t}\n\n\t\tmergedGeometry.setIndex( mergedIndex );\n\n\t}\n\n\t// merge attributes\n\n\tfor ( const name in attributes ) {\n\n\t\tconst mergedAttribute = mergeBufferAttributes( attributes[ name ] );\n\n\t\tif ( ! mergedAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' attribute.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tmergedGeometry.setAttribute( name, mergedAttribute );\n\n\t}\n\n\t// merge morph attributes\n\n\tfor ( const name in morphAttributes ) {\n\n\t\tconst numMorphTargets = morphAttributes[ name ][ 0 ].length;\n\n\t\tif ( numMorphTargets === 0 ) break;\n\n\t\tmergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n\t\tmergedGeometry.morphAttributes[ name ] = [];\n\n\t\tfor ( let i = 0; i < numMorphTargets; ++ i ) {\n\n\t\t\tconst morphAttributesToMerge = [];\n\n\t\t\tfor ( let j = 0; j < morphAttributes[ name ].length; ++ j ) {\n\n\t\t\t\tmorphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] );\n\n\t\t\t}\n\n\t\t\tconst mergedMorphAttribute = mergeBufferAttributes( morphAttributesToMerge );\n\n\t\t\tif ( ! mergedMorphAttribute ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' morphAttribute.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute );\n\n\t\t}\n\n\t}\n\n\treturn mergedGeometry;\n\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {BufferAttribute}\n */\nfunction mergeBufferAttributes( attributes ) {\n\n\tlet TypedArray;\n\tlet itemSize;\n\tlet normalized;\n\tlet arrayLength = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( itemSize === undefined ) itemSize = attribute.itemSize;\n\t\tif ( itemSize !== attribute.itemSize ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( normalized === undefined ) normalized = attribute.normalized;\n\t\tif ( normalized !== attribute.normalized ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.array.length;\n\n\t}\n\n\tconst array = new TypedArray( arrayLength );\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tarray.set( attributes[ i ].array, offset );\n\n\t\toffset += attributes[ i ].array.length;\n\n\t}\n\n\treturn new BufferAttribute( array, itemSize, normalized );\n\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {Array<InterleavedBufferAttribute>}\n */\nfunction interleaveAttributes( attributes ) {\n\n\t// Interleaves the provided attributes into an InterleavedBuffer and returns\n\t// a set of InterleavedBufferAttributes for each attribute\n\tlet TypedArray;\n\tlet arrayLength = 0;\n\tlet stride = 0;\n\n\t// calculate the the length and type of the interleavedBuffer\n\tfor ( let i = 0, l = attributes.length; i < l; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'AttributeBuffers of different types cannot be interleaved' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.array.length;\n\t\tstride += attribute.itemSize;\n\n\t}\n\n\t// Create the set of buffer attributes\n\tconst interleavedBuffer = new InterleavedBuffer( new TypedArray( arrayLength ), stride );\n\tlet offset = 0;\n\tconst res = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\tfor ( let j = 0, l = attributes.length; j < l; j ++ ) {\n\n\t\tconst attribute = attributes[ j ];\n\t\tconst itemSize = attribute.itemSize;\n\t\tconst count = attribute.count;\n\t\tconst iba = new InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, attribute.normalized );\n\t\tres.push( iba );\n\n\t\toffset += itemSize;\n\n\t\t// Move the data for each attribute into the new interleavedBuffer\n\t\t// at the appropriate offset\n\t\tfor ( let c = 0; c < count; c ++ ) {\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\tiba[ setters[ k ] ]( c, attribute[ getters[ k ] ]( c ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\n// returns a new, non-interleaved version of the provided attribute\nexport function deinterleaveAttribute( attribute ) {\n\n\tconst cons = attribute.data.array.constructor;\n\tconst count = attribute.count;\n\tconst itemSize = attribute.itemSize;\n\tconst normalized = attribute.normalized;\n\n\tconst array = new cons( count * itemSize );\n\tlet newAttribute;\n\tif ( attribute.isInstancedInterleavedBufferAttribute ) {\n\n\t\tnewAttribute = new InstancedBufferAttribute( array, itemSize, normalized, attribute.meshPerAttribute );\n\n\t} else {\n\n\t\tnewAttribute = new BufferAttribute( array, itemSize, normalized );\n\n\t}\n\n\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\tnewAttribute.setX( i, attribute.getX( i ) );\n\n\t\tif ( itemSize >= 2 ) {\n\n\t\t\tnewAttribute.setY( i, attribute.getY( i ) );\n\n\t\t}\n\n\t\tif ( itemSize >= 3 ) {\n\n\t\t\tnewAttribute.setZ( i, attribute.getZ( i ) );\n\n\t\t}\n\n\t\tif ( itemSize >= 4 ) {\n\n\t\t\tnewAttribute.setW( i, attribute.getW( i ) );\n\n\t\t}\n\n\t}\n\n\treturn newAttribute;\n\n}\n\n// deinterleaves all attributes on the geometry\nexport function deinterleaveGeometry( geometry ) {\n\n\tconst attributes = geometry.attributes;\n\tconst morphTargets = geometry.morphTargets;\n\tconst attrMap = new Map();\n\n\tfor ( const key in attributes ) {\n\n\t\tconst attr = attributes[ key ];\n\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( ! attrMap.has( attr ) ) {\n\n\t\t\t\tattrMap.set( attr, deinterleaveAttribute( attr ) );\n\n\t\t\t}\n\n\t\t\tattributes[ key ] = attrMap.get( attr );\n\n\t\t}\n\n\t}\n\n\tfor ( const key in morphTargets ) {\n\n\t\tconst attr = morphTargets[ key ];\n\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( ! attrMap.has( attr ) ) {\n\n\t\t\t\tattrMap.set( attr, deinterleaveAttribute( attr ) );\n\n\t\t\t}\n\n\t\t\tmorphTargets[ key ] = attrMap.get( attr );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * @param {Array<BufferGeometry>} geometry\n * @return {number}\n */\nfunction estimateBytesUsed( geometry ) {\n\n\t// Return the estimated memory used by this geometry in bytes\n\t// Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n\t// for InterleavedBufferAttributes.\n\tlet mem = 0;\n\tfor ( const name in geometry.attributes ) {\n\n\t\tconst attr = geometry.getAttribute( name );\n\t\tmem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n\n\t}\n\n\tconst indices = geometry.getIndex();\n\tmem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n\treturn mem;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} tolerance\n * @return {BufferGeometry>}\n */\nfunction mergeVertices( geometry, tolerance = 1e-4 ) {\n\n\ttolerance = Math.max( tolerance, Number.EPSILON );\n\n\t// Generate an index buffer if the geometry doesn't have one, or optimize it\n\t// if it's already available.\n\tconst hashToIndex = {};\n\tconst indices = geometry.getIndex();\n\tconst positions = geometry.getAttribute( 'position' );\n\tconst vertexCount = indices ? indices.count : positions.count;\n\n\t// next value for triangle indices\n\tlet nextIndex = 0;\n\n\t// attributes and new attribute arrays\n\tconst attributeNames = Object.keys( geometry.attributes );\n\tconst attrArrays = {};\n\tconst morphAttrsArrays = {};\n\tconst newIndices = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\n\t// initialize the arrays\n\tfor ( let i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\tconst name = attributeNames[ i ];\n\n\t\tattrArrays[ name ] = [];\n\n\t\tconst morphAttr = geometry.morphAttributes[ name ];\n\t\tif ( morphAttr ) {\n\n\t\t\tmorphAttrsArrays[ name ] = new Array( morphAttr.length ).fill().map( () => [] );\n\n\t\t}\n\n\t}\n\n\t// convert the error tolerance to an amount of decimal places to truncate to\n\tconst decimalShift = Math.log10( 1 / tolerance );\n\tconst shiftMultiplier = Math.pow( 10, decimalShift );\n\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\tconst index = indices ? indices.getX( i ) : i;\n\n\t\t// Generate a hash for the vertex attributes at the current index 'i'\n\t\tlet hash = '';\n\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\tconst name = attributeNames[ j ];\n\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\tconst itemSize = attribute.itemSize;\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t// double tilde truncates the decimal value\n\t\t\t\thash += `${ ~ ~ ( attribute[ getters[ k ] ]( index ) * shiftMultiplier ) },`;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Add another reference to the vertex if it's already\n\t\t// used by another index\n\t\tif ( hash in hashToIndex ) {\n\n\t\t\tnewIndices.push( hashToIndex[ hash ] );\n\n\t\t} else {\n\n\t\t\t// copy data to the new index in the attribute arrays\n\t\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\t\tconst name = attributeNames[ j ];\n\t\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\t\tconst morphAttr = geometry.morphAttributes[ name ];\n\t\t\t\tconst itemSize = attribute.itemSize;\n\t\t\t\tconst newarray = attrArrays[ name ];\n\t\t\t\tconst newMorphArrays = morphAttrsArrays[ name ];\n\n\t\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\tconst getterFunc = getters[ k ];\n\t\t\t\t\tnewarray.push( attribute[ getterFunc ]( index ) );\n\n\t\t\t\t\tif ( morphAttr ) {\n\n\t\t\t\t\t\tfor ( let m = 0, ml = morphAttr.length; m < ml; m ++ ) {\n\n\t\t\t\t\t\t\tnewMorphArrays[ m ].push( morphAttr[ m ][ getterFunc ]( index ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\thashToIndex[ hash ] = nextIndex;\n\t\t\tnewIndices.push( nextIndex );\n\t\t\tnextIndex ++;\n\n\t\t}\n\n\t}\n\n\t// Generate typed arrays from new attribute arrays and update\n\t// the attributeBuffers\n\tconst result = geometry.clone();\n\tfor ( let i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\tconst name = attributeNames[ i ];\n\t\tconst oldAttribute = geometry.getAttribute( name );\n\n\t\tconst buffer = new oldAttribute.array.constructor( attrArrays[ name ] );\n\t\tconst attribute = new BufferAttribute( buffer, oldAttribute.itemSize, oldAttribute.normalized );\n\n\t\tresult.setAttribute( name, attribute );\n\n\t\t// Update the attribute arrays\n\t\tif ( name in morphAttrsArrays ) {\n\n\t\t\tfor ( let j = 0; j < morphAttrsArrays[ name ].length; j ++ ) {\n\n\t\t\t\tconst oldMorphAttribute = geometry.morphAttributes[ name ][ j ];\n\n\t\t\t\tconst buffer = new oldMorphAttribute.array.constructor( morphAttrsArrays[ name ][ j ] );\n\t\t\t\tconst morphAttribute = new BufferAttribute( buffer, oldMorphAttribute.itemSize, oldMorphAttribute.normalized );\n\t\t\t\tresult.morphAttributes[ name ][ j ] = morphAttribute;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// indices\n\n\tresult.setIndex( newIndices );\n\n\treturn result;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} drawMode\n * @return {BufferGeometry>}\n */\nfunction toTrianglesDrawMode( geometry, drawMode ) {\n\n\tif ( drawMode === TrianglesDrawMode ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.' );\n\t\treturn geometry;\n\n\t}\n\n\tif ( drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode ) {\n\n\t\tlet index = geometry.getIndex();\n\n\t\t// generate index if not present\n\n\t\tif ( index === null ) {\n\n\t\t\tconst indices = [];\n\n\t\t\tconst position = geometry.getAttribute( 'position' );\n\n\t\t\tif ( position !== undefined ) {\n\n\t\t\t\tfor ( let i = 0; i < position.count; i ++ ) {\n\n\t\t\t\t\tindices.push( i );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setIndex( indices );\n\t\t\t\tindex = geometry.getIndex();\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst numberOfTriangles = index.count - 2;\n\t\tconst newIndices = [];\n\n\t\tif ( drawMode === TriangleFanDrawMode ) {\n\n\t\t\t// gl.TRIANGLE_FAN\n\n\t\t\tfor ( let i = 1; i <= numberOfTriangles; i ++ ) {\n\n\t\t\t\tnewIndices.push( index.getX( 0 ) );\n\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// gl.TRIANGLE_STRIP\n\n\t\t\tfor ( let i = 0; i < numberOfTriangles; i ++ ) {\n\n\t\t\t\tif ( i % 2 === 0 ) {\n\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( ( newIndices.length / 3 ) !== numberOfTriangles ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );\n\n\t\t}\n\n\t\t// build final geometry\n\n\t\tconst newGeometry = geometry.clone();\n\t\tnewGeometry.setIndex( newIndices );\n\t\tnewGeometry.clearGroups();\n\n\t\treturn newGeometry;\n\n\t} else {\n\n\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode );\n\t\treturn geometry;\n\n\t}\n\n}\n\n/**\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n * Helpful for Raytracing or Decals.\n * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n * @return {Object} An Object with original position/normal attributes and morphed ones.\n */\nfunction computeMorphedAttributes( object ) {\n\n\tif ( object.geometry.isBufferGeometry !== true ) {\n\n\t\tconsole.error( 'THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.' );\n\t\treturn null;\n\n\t}\n\n\tconst _vA = new Vector3();\n\tconst _vB = new Vector3();\n\tconst _vC = new Vector3();\n\n\tconst _tempA = new Vector3();\n\tconst _tempB = new Vector3();\n\tconst _tempC = new Vector3();\n\n\tconst _morphA = new Vector3();\n\tconst _morphB = new Vector3();\n\tconst _morphC = new Vector3();\n\n\tfunction _calculateMorphedAttributeData(\n\t\tobject,\n\t\tattribute,\n\t\tmorphAttribute,\n\t\tmorphTargetsRelative,\n\t\ta,\n\t\tb,\n\t\tc,\n\t\tmodifiedAttributeArray\n\t) {\n\n\t\t_vA.fromBufferAttribute( attribute, a );\n\t\t_vB.fromBufferAttribute( attribute, b );\n\t\t_vC.fromBufferAttribute( attribute, c );\n\n\t\tconst morphInfluences = object.morphTargetInfluences;\n\n\t\tif ( morphAttribute && morphInfluences ) {\n\n\t\t\t_morphA.set( 0, 0, 0 );\n\t\t\t_morphB.set( 0, 0, 0 );\n\t\t\t_morphC.set( 0, 0, 0 );\n\n\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tconst influence = morphInfluences[ i ];\n\t\t\t\tconst morph = morphAttribute[ i ];\n\n\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t_tempA.fromBufferAttribute( morph, a );\n\t\t\t\t_tempB.fromBufferAttribute( morph, b );\n\t\t\t\t_tempC.fromBufferAttribute( morph, c );\n\n\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA, influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB, influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC, influence );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA.sub( _vA ), influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB.sub( _vB ), influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC.sub( _vC ), influence );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_vA.add( _morphA );\n\t\t\t_vB.add( _morphB );\n\t\t\t_vC.add( _morphC );\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\tobject.boneTransform( a, _vA );\n\t\t\tobject.boneTransform( b, _vB );\n\t\t\tobject.boneTransform( c, _vC );\n\n\t\t}\n\n\t\tmodifiedAttributeArray[ a * 3 + 0 ] = _vA.x;\n\t\tmodifiedAttributeArray[ a * 3 + 1 ] = _vA.y;\n\t\tmodifiedAttributeArray[ a * 3 + 2 ] = _vA.z;\n\t\tmodifiedAttributeArray[ b * 3 + 0 ] = _vB.x;\n\t\tmodifiedAttributeArray[ b * 3 + 1 ] = _vB.y;\n\t\tmodifiedAttributeArray[ b * 3 + 2 ] = _vB.z;\n\t\tmodifiedAttributeArray[ c * 3 + 0 ] = _vC.x;\n\t\tmodifiedAttributeArray[ c * 3 + 1 ] = _vC.y;\n\t\tmodifiedAttributeArray[ c * 3 + 2 ] = _vC.z;\n\n\t}\n\n\tconst geometry = object.geometry;\n\tconst material = object.material;\n\n\tlet a, b, c;\n\tconst index = geometry.index;\n\tconst positionAttribute = geometry.attributes.position;\n\tconst morphPosition = geometry.morphAttributes.position;\n\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\tconst normalAttribute = geometry.attributes.normal;\n\tconst morphNormal = geometry.morphAttributes.position;\n\n\tconst groups = geometry.groups;\n\tconst drawRange = geometry.drawRange;\n\tlet i, j, il, jl;\n\tlet group;\n\tlet start, end;\n\n\tconst modifiedPosition = new Float32Array( positionAttribute.count * positionAttribute.itemSize );\n\tconst modifiedNormal = new Float32Array( normalAttribute.count * normalAttribute.itemSize );\n\n\tif ( index !== null ) {\n\n\t\t// indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = index.getX( j );\n\t\t\t\t\tb = index.getX( j + 1 );\n\t\t\t\t\tc = index.getX( j + 2 );\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = index.getX( i );\n\t\t\t\tb = index.getX( i + 1 );\n\t\t\t\tc = index.getX( i + 2 );\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\t// non-indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = j;\n\t\t\t\t\tb = j + 1;\n\t\t\t\t\tc = j + 2;\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = i;\n\t\t\t\tb = i + 1;\n\t\t\t\tc = i + 2;\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tconst morphedPositionAttribute = new Float32BufferAttribute( modifiedPosition, 3 );\n\tconst morphedNormalAttribute = new Float32BufferAttribute( modifiedNormal, 3 );\n\n\treturn {\n\n\t\tpositionAttribute: positionAttribute,\n\t\tnormalAttribute: normalAttribute,\n\t\tmorphedPositionAttribute: morphedPositionAttribute,\n\t\tmorphedNormalAttribute: morphedNormalAttribute\n\n\t};\n\n}\n\nfunction mergeGroups( geometry ) {\n\n\tif ( geometry.groups.length === 0 ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge.' );\n\t\treturn geometry;\n\n\t}\n\n\tlet groups = geometry.groups;\n\n\t// sort groups by material index\n\n\tgroups = groups.sort( ( a, b ) => {\n\n\t\tif ( a.materialIndex !== b.materialIndex ) return a.materialIndex - b.materialIndex;\n\n\t\treturn a.start - b.start;\n\n\t} );\n\n\t// create index for non-indexed geometries\n\n\tif ( geometry.getIndex() === null ) {\n\n\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\t\tconst indices = [];\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i += 3 ) {\n\n\t\t\tindices.push( i, i + 1, i + 2 );\n\n\t\t}\n\n\t\tgeometry.setIndex( indices );\n\n\t}\n\n\t// sort index\n\n\tconst index = geometry.getIndex();\n\n\tconst newIndices = [];\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tconst groupStart = group.start;\n\t\tconst groupLength = groupStart + group.count;\n\n\t\tfor ( let j = groupStart; j < groupLength; j ++ ) {\n\n\t\t\tnewIndices.push( index.getX( j ) );\n\n\t\t}\n\n\t}\n\n\tgeometry.dispose(); // Required to force buffer recreation\n\tgeometry.setIndex( newIndices );\n\n\t// update groups indices\n\n\tlet start = 0;\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tgroup.start = start;\n\t\tstart += group.count;\n\n\t}\n\n\t// merge groups\n\n\tlet currentGroup = groups[ 0 ];\n\n\tgeometry.groups = [ currentGroup ];\n\n\tfor ( let i = 1; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tif ( currentGroup.materialIndex === group.materialIndex ) {\n\n\t\t\tcurrentGroup.count += group.count;\n\n\t\t} else {\n\n\t\t\tcurrentGroup = group;\n\t\t\tgeometry.groups.push( currentGroup );\n\n\t\t}\n\n\t}\n\n\treturn geometry;\n\n}\n\nexport {\n\tcomputeTangents,\n\tcomputeMikkTSpaceTangents,\n\tmergeBufferGeometries,\n\tmergeBufferAttributes,\n\tinterleaveAttributes,\n\testimateBytesUsed,\n\tmergeVertices,\n\ttoTrianglesDrawMode,\n\tcomputeMorphedAttributes,\n\tmergeGroups\n};\n"],"names":["DecalGeometry","BufferGeometry","constructor","mesh","position","orientation","size","super","vertices","normals","uvs","plane","Vector3","projectorMatrix","Matrix4","makeRotationFromEuler","setPosition","projectorMatrixInverse","pushDecalVertex","decalVertices","vertex","normal","applyMatrix4","matrixWorld","transformDirection","push","DecalVertex","clone","clipGeometry","inVertices","plane2","outVertices","s","Math","abs","dot","i","length","v1Out","v2Out","v3Out","nV1","nV2","nV3","nV4","total","clip","v0","v1","p","d0","s0","x","y","z","copy","invert","geometry","isGeometry","console","error","positionAttribute","attributes","normalAttribute","index","count","fromBufferAttribute","getX","set","decalVertex","generate","this","setAttribute","Float32BufferAttribute","vecToArray","vec","arguments","undefined","Array","isArray","THREE","Decal","_ref","debug","children","rotation","scale","props","ref","React","helper","parent","current","target","Error","state","applyProps","identity","o","lookAt","rotateZ","dispose","_extends","transparent","polygonOffset","polygonOffsetFactor","wireframe","_taskCache","WeakMap","DRACOLoader","Loader","manager","decoderPath","decoderConfig","decoderBinary","decoderPending","workerLimit","workerPool","workerNextTaskID","workerSourceURL","defaultAttributeIDs","color","uv","defaultAttributeTypes","setDecoderPath","path","setDecoderConfig","config","setWorkerLimit","load","url","onLoad","onProgress","onError","loader","FileLoader","setPath","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","buffer","taskConfig","attributeIDs","attributeTypes","useUniqueIDs","decodeGeometry","then","catch","decodeDracoFile","callback","attribute","type","BYTES_PER_ELEMENT","name","taskKey","JSON","stringify","has","cachedTask","get","key","promise","byteLength","worker","taskID","taskCost","geometryPending","_getWorker","_worker","Promise","resolve","reject","_callbacks","postMessage","id","message","_createGeometry","_releaseTask","geometryData","setIndex","BufferAttribute","array","itemSize","_loadLibrary","responseType","preload","_initDecoder","useJS","WebAssembly","librariesPending","all","libraries","jsContent","wasmBinary","fn","DRACOWorker","toString","body","substring","indexOf","lastIndexOf","join","URL","createObjectURL","Blob","worker2","Worker","_taskCosts","_taskLoad","onmessage","e","data","sort","a","b","log","map","terminate","decodeAttribute","draco","decoder","dracoGeometry","attributeName","attributeType","numComponents","num_components","numValues","num_points","dataType","Float32Array","DT_FLOAT32","Int8Array","DT_INT8","Int16Array","DT_INT16","Int32Array","DT_INT32","Uint8Array","DT_UINT8","Uint16Array","DT_UINT16","Uint32Array","DT_UINT32","getDracoDataType","ptr","_malloc","GetAttributeDataArrayForAllPoints","HEAPF32","slice","_free","onModuleLoaded","DracoDecoderModule","module","Decoder","decoderBuffer","DecoderBuffer","Init","decodingStatus","geometryType","GetEncodedGeometryType","TRIANGULAR_MESH","Mesh","DecodeBufferToMesh","POINT_CLOUD","PointCloud","DecodeBufferToPointCloud","ok","error_msg","self","attributeID","GetAttributeByUniqueId","GetAttributeId","GetAttribute","numFaces","num_faces","numIndices","GetTrianglesUInt32Array","decodeIndex","destroy","buffers","attr","generated","MeshoptDecoder","detector","wasmpack","supported","instance","wasm","validate","instantiate","result","ch","charCodeAt","write","unpack","exports","__wasm_call_ctors","decode","fun","source","filter","sbrk","count4","tp","sp","heap","memory","res","subarray","concat","filters","NONE","OCTAHEDRAL","QUATERNION","EXPONENTIAL","decoders","ATTRIBUTES","TRIANGLES","INDICES","ready","decodeVertexBuffer","meshopt_decodeVertexBuffer","decodeIndexBuffer","meshopt_decodeIndexBuffer","decodeIndexSequence","meshopt_decodeIndexSequence","decodeGltfBuffer","mode","toTrianglesDrawMode","drawMode","TrianglesDrawMode","warn","TriangleFanDrawMode","TriangleStripDrawMode","getIndex","indices","getAttribute","numberOfTriangles","newIndices","newGeometry","clearGroups","version","parseInt","REVISION","replace","GLTFLoader","dracoLoader","ktx2Loader","meshoptDecoder","pluginCallbacks","register","parser","GLTFMaterialsClearcoatExtension","GLTFTextureBasisUExtension","GLTFTextureWebPExtension","GLTFTextureAVIFExtension","GLTFMaterialsSheenExtension","GLTFMaterialsTransmissionExtension","GLTFMaterialsVolumeExtension","GLTFMaterialsIorExtension","GLTFMaterialsEmissiveStrengthExtension","GLTFMaterialsSpecularExtension","GLTFMaterialsIridescenceExtension","GLTFMaterialsAnisotropyExtension","GLTFLightsExtension","GLTFMeshoptCompression","GLTFMeshGpuInstancing","scope","resourcePath","LoaderUtils","extractUrlBase","itemStart","_onError","itemError","itemEnd","parse","gltf","setDRACOLoader","setDDSLoader","setKTX2Loader","setMeshoptDecoder","unregister","splice","json","extensions","plugins","ArrayBuffer","decodeText","BINARY_EXTENSION_HEADER_MAGIC","EXTENSIONS","KHR_BINARY_GLTF","GLTFBinaryExtension","content","asset","GLTFParser","crossOrigin","fileLoader","plugin","extensionsUsed","extensionName","extensionsRequired","KHR_MATERIALS_UNLIT","GLTFMaterialsUnlitExtension","KHR_DRACO_MESH_COMPRESSION","GLTFDracoMeshCompressionExtension","KHR_TEXTURE_TRANSFORM","GLTFTextureTransformExtension","KHR_MESH_QUANTIZATION","GLTFMeshQuantizationExtension","setExtensions","setPlugins","parseAsync","GLTFRegistry","objects","add","object","remove","removeAll","KHR_LIGHTS_PUNCTUAL","KHR_MATERIALS_CLEARCOAT","KHR_MATERIALS_IOR","KHR_MATERIALS_SHEEN","KHR_MATERIALS_SPECULAR","KHR_MATERIALS_TRANSMISSION","KHR_MATERIALS_IRIDESCENCE","KHR_MATERIALS_ANISOTROPY","KHR_MATERIALS_VOLUME","KHR_TEXTURE_BASISU","KHR_MATERIALS_EMISSIVE_STRENGTH","EXT_TEXTURE_WEBP","EXT_TEXTURE_AVIF","EXT_MESHOPT_COMPRESSION","EXT_MESH_GPU_INSTANCING","cache","refs","uses","_markDefs","nodeDefs","nodes","nodeIndex","nodeLength","nodeDef","light","_addNodeRef","_loadLight","lightIndex","cacheKey","dependency","lightDef","lights","lightNode","Color","fromArray","range","DirectionalLight","PointLight","distance","SpotLight","spot","innerConeAngle","outerConeAngle","PI","angle","penumbra","decay","assignExtrasToUserData","intensity","createUniqueName","getDependency","createNodeAttachment","self2","_getNodeRef","getMaterialType","MeshBasicMaterial","extendParams","materialParams","materialDef","pending","opacity","metallicRoughness","pbrMetallicRoughness","baseColorFactor","baseColorTexture","assignTexture","extendMaterialParams","materialIndex","materials","emissiveStrength","emissiveIntensity","MeshPhysicalMaterial","extension","clearcoatFactor","clearcoat","clearcoatTexture","clearcoatRoughnessFactor","clearcoatRoughness","clearcoatRoughnessTexture","clearcoatNormalTexture","clearcoatNormalScale","Vector2","iridescenceFactor","iridescence","iridescenceTexture","iridescenceIor","iridescenceIOR","iridescenceThicknessRange","iridescenceThicknessMinimum","iridescenceThicknessMaximum","iridescenceThicknessTexture","sheenColor","sheenRoughness","sheen","sheenColorFactor","sheenRoughnessFactor","sheenColorTexture","sheenRoughnessTexture","transmissionFactor","transmission","transmissionTexture","thickness","thicknessFactor","thicknessTexture","attenuationDistance","Infinity","colorArray","attenuationColor","ior","specularIntensity","specularFactor","specularTexture","specularColorFactor","specularColor","specularColorTexture","anisotropyStrength","anisotropy","anisotropyRotation","anisotropyTexture","loadTexture","textureIndex","textureDef","textures","options","loadTextureImage","isSupported","images","textureLoader","uri","handler","getHandler","detectSupport","image","Image","src","onload","onerror","height","loadBufferView","bufferView","bufferViews","extensionDef","byteOffset","stride","byteStride","decodeGltfBufferAsync","res2","createNodeMesh","meshDef","meshes","primitive","primitives","WEBGL_CONSTANTS","TRIANGLE_STRIP","TRIANGLE_FAN","attributesDef","accessor","results","nodeObject","pop","isGroup","instancedMeshes","m","q","Quaternion","instancedMesh","InstancedMesh","material","TRANSLATION","ROTATION","SCALE","setMatrixAt","compose","Object3D","prototype","call","assignFinalMaterial","clear","BINARY_EXTENSION_CHUNK_TYPES","headerView","DataView","header","magic","getUint32","chunkContentsLength","chunkView","chunkIndex","chunkLength","chunkType","contentArray","decodePrimitive","bufferViewIndex","gltfAttributeMap","threeAttributeMap","attributeNormalizedMap","attributeTypeMap","threeAttributeName","toLowerCase","accessorDef","accessors","componentType","WEBGL_COMPONENT_TYPES","normalized","extendTexture","texture","transform","texCoord","channel","offset","repeat","needsUpdate","GLTFCubicSplineInterpolant","Interpolant","parameterPositions","sampleValues","sampleSize","resultBuffer","copySampleValue_","values","valueSize","interpolate_","i1","t0","t","t1","stride2","stride3","td","pp","ppp","offset1","offset0","s2","s3","s1","p0","m0","p1","m1","_q","GLTFCubicSplineQuaternionInterpolant","normalize","toArray","FLOAT","FLOAT_MAT3","FLOAT_MAT4","FLOAT_VEC2","FLOAT_VEC3","FLOAT_VEC4","LINEAR","REPEAT","SAMPLER_2D","POINTS","LINES","LINE_LOOP","LINE_STRIP","UNSIGNED_BYTE","UNSIGNED_SHORT","WEBGL_FILTERS","NearestFilter","LinearFilter","NearestMipmapNearestFilter","LinearMipmapNearestFilter","NearestMipmapLinearFilter","LinearMipmapLinearFilter","WEBGL_WRAPPINGS","ClampToEdgeWrapping","MirroredRepeatWrapping","RepeatWrapping","WEBGL_TYPE_SIZES","SCALAR","VEC2","VEC3","VEC4","MAT2","MAT3","MAT4","POSITION","NORMAL","TANGENT","TEXCOORD_0","TEXCOORD_1","TEXCOORD_2","TEXCOORD_3","COLOR_0","WEIGHTS_0","JOINTS_0","PATH_PROPERTIES","translation","weights","INTERPOLATION","CUBICSPLINE","InterpolateLinear","STEP","InterpolateDiscrete","ALPHA_MODES","addUnknownExtensionsToUserData","knownExtensions","objectDef","userData","gltfExtensions","gltfDef","extras","Object","assign","updateMorphTargets","il","morphTargetInfluences","targetNames","morphTargetDictionary","createPrimitiveKey","primitiveDef","geometryKey","dracoExtension","createAttributesKey","targets","attributesKey","keys","getNormalizedComponentScale","_identityMatrix","associations","Map","primitiveCache","nodeCache","meshCache","cameraCache","lightCache","sourceCache","textureCache","nodeNamesUsed","isSafari","isFirefox","firefoxVersion","navigator","userAgent","test","match","createImageBitmap","TextureLoader","ImageBitmapLoader","setCrossOrigin","_invokeAll","ext","beforeRoot","getDependencies","dependencies","scene","scenes","animations","cameras","afterRoot","skinDefs","skins","meshDefs","skinIndex","skinLength","joints","isBone","skin","isSkinnedMesh","camera","updateMappings","original","mappings","child","entries","_invokeOne","func","unshift","loadScene","loadNode","loadMesh","loadAccessor","loadBuffer","loadMaterial","loadSkin","loadAnimation","loadCamera","defs","def","bufferIndex","bufferDef","resolveURL","bufferViewDef","accessorIndex","sparse","TypedArray","pendingBufferViews","elementBytes","itemBytes","bufferAttribute","ibSlice","floor","ibCacheKey","ib","InterleavedBuffer","InterleavedBufferAttribute","itemSizeIndices","TypedArrayIndices","byteOffsetIndices","byteOffsetValues","sparseIndices","sparseValues","setX","setY","setZ","setW","sourceIndex","sourceDef","sampler","loadImageSource","flipY","startsWith","samplers","magFilter","minFilter","wrapS","wrapT","webkitURL","sourceURI","isObjectURL","blob","mimeType","sourceURI2","isImageBitmapLoader","imageBitmap","Texture","revokeObjectURL","search","mapName","mapDef","encoding","gltfReference","colorSpace","useDerivativeTangents","tangent","useVertexColors","useFlatShading","isPoints","uuid","pointsMaterial","PointsMaterial","Material","sizeAttenuation","isLine","lineMaterial","LineBasicMaterial","cachedMaterial","vertexColors","flatShading","normalScale","MeshStandardMaterial","materialType","kmuExtension","metalness","metallicFactor","roughness","roughnessFactor","metallicRoughnessTexture","doubleSided","side","DoubleSide","alphaMode","depthWrite","alphaTest","alphaCutoff","normalTexture","occlusionTexture","strength","aoMapIntensity","emissiveFactor","emissive","emissiveTexture","originalName","sanitizedName","PropertyBinding","sanitizeNodeName","loadGeometries","createDracoPrimitive","addPrimitiveAttributes","cached","geometryPromise","meshIndex","depthTest","FrontSide","geometries","SkinnedMesh","normalizeSkinWeights","LineSegments","Line","LineLoop","Points","morphAttributes","group","Group","cameraIndex","cameraDef","params","PerspectiveCamera","MathUtils","radToDeg","yfov","aspectRatio","znear","zfar","OrthographicCamera","xmag","ymag","skinDef","_loadNodeShallow","inverseBindMatrices","jointNodes","bones","boneInverses","jointNode","mat","Skeleton","animationIndex","animationDef","animationName","pendingNodes","pendingInputAccessors","pendingOutputAccessors","pendingSamplers","pendingTargets","channels","node","input","parameters","output","inputAccessors","outputAccessors","tracks","inputAccessor","outputAccessor","TypedKeyframeTrack","updateMatrix","NumberKeyframeTrack","QuaternionKeyframeTrack","VectorKeyframeTrack","targetName","interpolation","traverse","outputArray","scaled","j","jl","track","createInterpolant","times","getValueSize","isInterpolantFactoryMethodGLTFCubicSpline","AnimationClip","isMesh","nodePending","childPending","childrenDef","skeletonPending","skeleton","bind","nodeName","meshPromise","forEach","Bone","matrix","quaternion","sceneIndex","sceneDef","nodeIds","reducedAssociations","value","node2","reduceAssociations","assignAttributeAccessor","gltfAttributeName","accessor2","box","Box3","min","max","boxScale","multiplyScalar","maxDisplacement","vector","expandByVector","boundingBox","sphere","Sphere","getCenter","center","radius","distanceTo","boundingSphere","computeBounds","hasMorphPosition","hasMorphNormal","hasMorphColor","pendingPositionAccessors","pendingNormalAccessors","pendingColorAccessors","pendingAccessor","morphPositions","morphNormals","morphColors","morphTargetsRelative","addMorphTargets","useDraco","useMeshopt","extendLoader","useGLTF","useMeshOpt","useLoader","IsObject","useTexture","gl","useThree","useLayoutEffect","useEffect","initTexture","keyed","mergeBufferGeometries","useGroups","isIndexed","attributesUsed","Set","morphAttributesUsed","mergedGeometry","attributesCount","mergedUserData","addGroup","indexOffset","mergedIndex","mergedAttribute","mergeBufferAttributes","numMorphTargets","morphAttributesToMerge","mergedMorphAttribute","arrayLength","isInterleavedBufferAttribute"],"sourceRoot":""}